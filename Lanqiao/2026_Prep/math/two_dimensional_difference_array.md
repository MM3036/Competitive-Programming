# 二维差分数组 (2D Difference Array)：算法原理与高效实现

## 一、 核心知识点：二维差分

### 1. 定义与用途
二维差分是**二维前缀和**的逆运算。它主要用于解决以下问题：在 $O(1)$ 时间复杂度内对矩阵的一个**子矩形区域**进行统一数值修改（加减 $c$）。

### 2. 核心思想：延迟更新 (Lazy Propagation)
不直接修改原数组，而是将修改操作记录在差分数组 $D$ 中。

### 3. 四点修改 (容斥原理)
对子矩阵 $(x_1, y_1) \sim (x_2, y_2)$ 的修改，只需更新差分数组的四个关键点，以精确控制增量的影响范围：

$$\begin{aligned}
D[x_1][y_1] &\mathrel{+}= c \quad (\text{开始影响全部右下方区域}) \\
D[x_1][y_2+1] &\mathrel{-}= c \quad (\text{抵消右侧多余影响}) \\
D[x_2+1][y_1] &\mathrel{-}= c \quad (\text{抵消下方多余影响}) \\
D[x_2+1][y_2+1] &\mathrel{+}= c \quad (\text{补回重复抵消的部分})
\end{aligned}$$

### 4. 还原
所有修改完成后，对差分数组求一次**二维前缀和**，即可得到最终的数值矩阵。

---

## 二、 题目描述

*   **场景**：在一个 $N \times N$ 的网格中，进行 $M$ 次区域操作。
*   **输入**：
    1. 网格大小 $N$ 及操作次数 $M$。
    2. 初始网格的具体数值矩阵 $A$（非必选，视题目而定）。
    3. $M$ 组操作指令，每组包含：左上角 $(x_1, y_1)$、右下角 $(x_2, y_2)$ 和增量值 $c$。
*   **输出**：操作完成后的最终完整矩阵。

---

## 三、 关键编程技巧解析

### 1. `enumerate` 与 坐标映射
*   **enumerate 的作用**：在遍历输入数据（如一行列表）时，同时获取索引（index）和数值（value）。
*   **索引转换 (0-based vs 1-based)**：
    *   **输入数据**：Python 列表索引从 0 开始（$j \in [0, N-1]$）。
    *   **差分数组**：为了配合 **Padding（哨兵）** 技巧防止越界，通常使用从 1 开始的索引（$j \in [1, N]$）。
    *   **映射关系**：在填充差分数组时，列坐标通常进行 `j + 1` 的偏移。

### 2. `insert(x1, y1, x2, y2, c)` 函数封装
这是一个通用的区域修改函数。
*   **单点初始化的特殊性**：当处理初始矩阵中的单个数值 $A[i][j]$ 时，该点在几何上等同于一个长宽均为 1 的子矩阵。
*   **技巧**：调用 `insert(i, j, i, j, val)`。此操作将“单点赋值”完美统一为“区域修改”。

---

## 四、 进阶：非零初始矩阵的处理方法对比

当初始矩阵 $A$ 不全为 0 时，构建差分数组 $D$ 有两种常用方法：

| 特性 | 方法一：数学公式构造法 | 方法二：复用 Update 函数法（推荐） |
| :--- | :--- | :--- |
| **原理** | 逆推二维前缀和公式：$D_{i,j} = A_{i,j} - A_{i-1,j} - A_{i,j-1} + A_{i-1,j-1}$ | 将初始值视为在一个全 0 矩阵上进行的 $N^2$ 次单点修改。 |
| **实现** | 需显式计算差值，依赖 $i-1, j-1$ 的值。 | 遍历原数组，调用 `insert(i, j, i, j, A[i][j])`。 |
| **优点** | 数学逻辑严密。 | **逻辑高度统一**：初始化与后续修改共用一套逻辑；**无需边界判断**；**空间优化**。 |
| **缺点** | 处理边界（$i=1, j=1$）易越界，需额外判断。 | 常数级计算量略大，但在竞赛中可忽略。 |

---

## 五、 核心理解总结

**“差分数组的本质就是增量”**

*   **统一性**：无论是矩阵初始存在的数值，还是后续指令要求的修改，在差分算法视角下，本质上都是对网格施加的**“变化量”**。
*   **处理流程**：
    1. 假设背景全 0。
    2. 将“初始值”作为第一波增量打入差分数组。
    3. 将“操作指令”作为第二波增量打入差分数组。
    4. 最后一次性求前缀和进行结算（还原）。

---

## 六、 第一版正确代码实现 (初始数据全零)

```python
import sys
data = map(int, sys.stdin.read().split())
N = next(data)
M = next(data)
diff = [[0] * (N + 2) for _ in range(N + 2)]
for i in range(M):
    x_1 = next(data)
    y_1 = next(data)
    x_2 = next(data)
    y_2 = next(data)
    diff[x_1][y_1] += 1
    diff[x_1][y_2 + 1] -= 1
    diff[x_2 + 1][y_1] -= 1
    diff[x_2 + 1][y_2 + 1] += 1

for i in range(1, N + 1):
    for j in range(1, N + 1):
        diff[i][j] = diff[i][j] + diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]
for i in range(1, N + 1):
    sys.stdout.write(' '.join(map(str, diff[i][1:N+1])) + '\n')
```

---

## 七、进阶正确代码实现 (初始数据不为零)

```python
import sys

# 1. 设置快读
input = sys.stdin.read
data = input().split()
iterator = iter(data)

def next_int():
    return int(next(iterator))

N = next_int()
M = next_int()

# 2. 开差分数组 (Padding: N+2)
diff = [[0] * (N + 2) for _ in range(N + 2)]

# 3. 定义通用的修改函数
def insert(x1, y1, x2, y2, val):
    diff[x1][y1]     += val
    diff[x1][y2 + 1] -= val
    diff[x2 + 1][y1] -= val
    diff[x2 + 1][y2 + 1] += val

# ==========================================
# 阶段一：读取初始矩阵 (用 enumerate)
# ==========================================
for i in range(1, N + 1):
    # i 代表当前是第几行 (1, 2, 3...)
    
    # 我们这里不需要一行行读字符串再split，因为上面用了 iter(data) 全局迭代器
    # 我们直接连续读 N 个数，就是这一行的数值
    for j in range(N): 
        # j 代表当前是第几列 (0, 1, 2... 因为 range 是从 0 开始)
        
        val = next_int() # 读入当前格子的数值
        
        # 【重点】把这个数值 val，作为增量，插入到 diff 数组
        # 坐标转换：行是 i，列是 j+1 (把0-based转成1-based)
        insert(i, j + 1, i, j + 1, val)

# ==========================================
# 阶段二：处理 M 次操作
# ==========================================
for _ in range(M):
    x1 = next_int()
    y1 = next_int()
    x2 = next_int()
    y2 = next_int()
    # 假设题目没给增量c，就是默认+1；如果给了就读入c
    insert(x1, y1, x2, y2, 1)

# ==========================================
# 阶段三：求前缀和并输出
# ==========================================
for i in range(1, N + 1):
    output_row = []
    for j in range(1, N + 1):
        diff[i][j] = diff[i][j] + diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1]
        output_row.append(str(diff[i][j]))
    sys.stdout.write(' '.join(output_row) + '\n')
```

---
