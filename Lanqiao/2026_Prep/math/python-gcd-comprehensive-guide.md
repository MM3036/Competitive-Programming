## 1. 核心逻辑：从“切蛋糕”到“数学归纳”

### 直观画面（几何法）
*   **场景**：试图用最大的正方形填满一个长方形（例如 $10 \times 6$）。
*   **操作**：用短边去量长边，剩下的余数（$10 \% 6 = 4$）构成了新的小长方形。
*   **转化**：原问题 $GCD(10, 6)$ $\rightarrow$ 变成了新问题 $GCD(6, 4)$。
*   **终止**：直到没有余数（能铺满），此时的短边就是最大公约数。

### 数学本质（递归法）
$$GCD(a, b) = GCD(b, a \% b)$$
*   **公约数守恒定律**：$a$ 和 $b$ 的公约数，一定也是 $a \% b$（余数）的约数。
*   **提纯过程**：取余操作就像剥洋葱，层层剥去多余的倍数，因为公约数这种“基因”在减法/取余中是永恒守恒的，最后剩下的那个“核”就是 GCD。

---

## 2. 代码实现（背诵级）

### Python 极简版
记住口诀：“旧除数变被除数，旧余数变除数”。

```python
def gcd(a, b):
    while b != 0:
        # a 变成旧的 b
        # b 变成旧的 a % b (这一步是同时发生的)
        a, b = b, a % b
    return a  # 当 b 为 0 时，a 就是结果
```

**为什么总是记不住顺序？**
1. 想象左手拿大数，右手拿小数。
2. 取余，把结果给右手。
3. 原来的右手交给左手。
4. 循环直到右手空了。

---

## 3. 你的核心疑点（思维突破口）

这里记录了理解算法最关键的两个逻辑卡点：

*   **Q1：为什么长边闲着没事要去“除以”宽边？**
    *   **本质**：这是一种**“测量”行为，或者叫“懒人减法”**。
    *   **解释**：我们在找公约数，目前手里唯一的尺子就是“宽边”。我们拿宽边去量长边，看看能塞下几个。除法（取余）只是为了快速算出“量不尽剩下的那一小截”（余数）。那一小截才是下一轮的新尺子。

*   **Q2：万一答案藏在“第一条和第二条宽边”的中间，被切坏了怎么办？**
    *   **本质**：“砖缝理论”（整除的离散性）。
    *   **解释**：$GCD$ 是铺满宽边 $B$ 的“基本地砖”。既然 $B$ 由整数块地砖组成，那么 $B$ 的倍数（我们切掉的部分）也一定是整数块地砖。
    *   **结论**：我们切刀落下的位置，永远在“地砖缝隙”里，绝对不会把公约数（地砖）切成两半。

---

## 4. 严谨推导：贝祖定理（Bézout's identity）

如果你需要从底层逻辑说服自己，记住这个公式：
$$z = a \cdot x + b \cdot y$$

*   **含义**：任何对两个整数 $x, y$ 进行的加减、取余操作，本质上都是它们的线性组合。
*   **推论**：提公因式：$z = GCD(x,y) \cdot (a \cdot m + b \cdot n)$。
*   **结果**：你能凑出来的任何数字 $z$，必须是 $GCD(x,y)$ 的倍数。你是逃不出“公约数网格”的。

---

## 5. 实战例题（面试必考）

### 例题一：求最小公倍数 (LCM)
*   **核心逻辑**：韦恩图（集合论）。
*   **原理**：两数相乘 ($a \times b$) 把公共部分 ($GCD$) 算了两次。除掉一次多余的，就是 LCM。
*   **公式**：$$LCM(a, b) = \frac{a \times b}{GCD(a, b)}$$

```python
def lcm(a, b):
    # 先除后乘（防止溢出，虽然Python不怕溢出，但是好习惯）
    return (a * b) // gcd(a, b)
```

### 例题二：倒水问题 (Water Jug Problem)
*   **题目**：有容量为 $x$ 和 $y$ 的壶，能倒出 $z$ 升水吗？
*   **核心逻辑**：“跳蚤跳步”。
*   **判据**：只要 $z$ 是 $GCD(x, y)$ 的倍数，且不超过总容量，就能成功。

```python
import math

def canMeasureWater(x, y, z):
    # 排除边界情况：目标水量太大，两个壶加起来都装不下
    if z > x + y:
        return False
    # 如果 z 是 0，或者 x+y 刚好等于 z，直接成功
    if z == 0 or z == x + y:
        return True
    
    # 核心逻辑：z 必须能被 gcd(x, y) 整除
    return z % math.gcd(x, y) == 0

# 测试：用 3 和 5 量出 4？
# gcd(3, 5) = 1。因为 4 是 1 的倍数，所以 True！
print(canMeasureWater(3, 5, 4)) 

# 测试：用 2 和 6 量出 5？
# gcd(2, 6) = 2。因为 5 不是 2 的倍数，所以 False！不可能量出来。
print(canMeasureWater(2, 6, 5))
```
```
