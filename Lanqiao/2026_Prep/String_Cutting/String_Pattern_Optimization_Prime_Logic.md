### 算法演进笔记：从逻辑判断到数学降维

#### 1. 基础阶段：列表(List) 与 集合(Set)
*   **列表法 (List):** 使用 `["lqb", "lbq", ...]`。每次查询 `in` 的复杂度是 $O(K)$（K为列表长度）。虽然逻辑简单，但属于线性搜索。
*   **集合法 (Set):** 将列表改为 `{...}`。利用哈希表存储，查询复杂度降至 $O(1)$。这是处理“存在性判断”的标准做法。
*   **注意：** 以上两种方法在 Python 中都需要进行**字符串切片** `s[i:i+3]`，这会产生大量临时对象，在处理千万级数据时会产生内存压力和 GC 耗时。

---

#### 2. 进阶阶段：异或(XOR) 与 ASCII 和（预过滤法）
**核心思想：** 利用加法和异或的**交换律**。无论字符如何排列，它们的总和与异或值是固定的。这种方法常用于快速排除不可能的子串。

**代码实现：**
```python
import sys

def solve_xor_sum():
    # 预读取数据
    s = sys.stdin.read().strip()
    n = len(s)
    
    # 目标指纹：l, q, b 的特征值
    target_sum = ord('l') + ord('q') + ord('b')    # 108+113+98 = 319
    target_xor = ord('l') ^ ord('q') ^ ord('b')    # 108^113^98 = 123
    # 最后的精确校验集
    valid_set = {"lqb", "lbq", "blq", "bql", "qlb", "qbl"}
    
    ans = 0
    i = 0
    while i <= n - 3:
        # 获取当前三个字符的 ASCII
        c1, c2, c3 = ord(s[i]), ord(s[i+1]), ord(s[i+2])
        
        # 第一层过滤：总和与异或值必须同时匹配（极快，不产生新对象）
        if (c1 + c2 + c3 == target_sum) and (c1 ^ c2 ^ c3 == target_xor):
            # 第二层过滤：通过数学测试后，再进行字符串切片做最终确认（防止极低概率的碰撞）
            if s[i:i+3] in valid_set:
                ans += 1
                i += 3
                continue
        i += 1
    print(ans)

# solve_xor_sum()
```

---

#### 3. 终极阶段：质数判别法（算术基本定理）
**核心思想：** 利用**唯一分解定理**。给每个目标字母分配一个唯一的**质数**，它们的乘积也是唯一的。这是一种“零碰撞”的数学方案，能直接跳过字符串切片和集合查找。

**数学原理：**
*   令 $l=2, q=3, b=5$。
*   只有且仅有 $\{2, 3, 5\}$ 这三个质数相乘结果为 $30$。
*   任何其他字母（如 'a'）如果参与运算，由于它不是这些因数，结果绝不会是 $30$（我们将非目标字符设为 $0$ 或大质数）。

**代码实现（极致性能版）：**
```python
import sys

def solve_prime_power():
    # 1. 快速读取
    s = sys.stdin.read().strip()
    n = len(s)
    
    # 2. 构建映射表：使用长度 256 的数组替代字典，下标访问达到硬件级速度
    # 默认值为 0，意味着任何非 lqb 字符都会让乘积变为 0，瞬间排除
    p_map = [0] * 256
    p_map[ord('l')] = 2
    p_map[ord('q')] = 3
    p_map[ord('b')] = 5
    
    ans = 0
    i = 0
    
    # 3. 将字符串转为字节数组，避免循环中反复调用 ord()
    # 在 Python 中，b_s[i] 直接返回整数 ASCII 值
    b_s = s.encode('ascii')
    
    while i <= n - 3:
        # 4. 获取质数指纹
        # 只要这三个位置的字符是 l,q,b 的任意排列，乘积必为 30
        product = p_map[b_s[i]] * p_map[b_s[i+1]] * p_map[b_s[i+2]]
        
        if product == 30:
            ans += 1
            i += 3  # 切割逻辑：跳过已使用的 3 个字符
        else:
            i += 1  # 移动一步继续探测
            
    print(ans)

# solve_prime_power()
```

---

### 总结与对比

| 算法阶段 | 核心逻辑 | 时间复杂度 | 内存开销 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| **1. 基础列表** | `in list` | $O(N \cdot K)$ | 高（频繁切片） | 适合小规模数据，代码最直接。 |
| **2. 哈希集合** | `in set` | $O(N)$ | 高（频繁切片） | $O(1)$ 查询，但切片复制字符串是瓶颈。 |
| **3. 异或与和** | 数学指纹过滤 | $O(N)$ | 中 | 极大地减少了切片次数，适合大多数竞赛。 |
| **4. 质数乘法** | 唯一分解定理 | $O(N)$ | **极低** | **最优解**。无需切片，无碰撞，直接在数值层面解决问题。 |

**经验之谈：**
*   当你在处理**“字母异位词”（即字符种类和数量相同，但顺序不同）**的问题时，**质数乘法**永远是降维打击的神器。
*   在 Python 中，如果追求极致速度，记得：**能用数组不用字典，能处理整数不处理字符串。**
