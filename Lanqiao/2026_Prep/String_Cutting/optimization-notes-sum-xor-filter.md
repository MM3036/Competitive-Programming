# 算法优化笔记：轻量级哈希剪枝与位运算的妙用

## 1. 核心问题：为什么我们需要“剪枝”？

在字符串处理或滑动窗口问题中，直接进行对象比较（如 `s[i:j] == target`）是非常昂贵的操作：

*   **时间成本**：字符串切片和比对通常是 $O(K)$（K为长度），涉及内存分配和数据拷贝。
*   **优化目标**：我们需要一种 $O(1)$ 的快速检查方法，在进行昂贵操作前，先通过廉价的数学运算排除掉 99% 的错误答案。

## 2. 解决方案：双重指纹过滤 (Sum-XOR Filter)

利用 CPU 极快的寄存器运算（加法和位运算），构建两个维度的“指纹”来描述目标对象。

**公式**

$$
\text{Check} = (\text{Sum}_{\text{window}} == \text{Sum}_{\text{target}}) \ \&\& \ (\text{XOR}_{\text{window}} == \text{XOR}_{\text{target}})
$$

### 维度解析

| 维度 | 运算符号 | 关注点 | 物理含义（类比） |
| :--- | :---: | :--- | :--- |
| **数值维** | 加法 (+) | 数值的大小与进位 | 物体的**“重量”** |
| **结构维** | 异或 (^) | 二进制位的特征，无进位 | 物体的**“形状”** |

### 逻辑流程

1.  **第一道门（数学过滤）**：先看“重量”和“形状”是否都对得上。
    *   如果 Sum 不同，排除。
    *   如果 Sum 相同但 XOR 不同，排除（防碰撞）。
2.  **第二道门（最终确认）**：只有两道数学题都算对了，才进行昂贵的 `s[i:i+3]` 字符串切片比对。

## 3. 深度解析：为什么必须是“异或 (XOR)”？

在 `&` (与)、`|` (或)、`^` (异或) 三兄弟中，只有异或是**“无损”且“敏感”**的。

### A. 信息熵的保留（不做黑洞）

*   **与 (&)**：倾向于变 0（黑洞效应）。参与运算的数越多，结果越趋近于 0，区分度丧失。
*   **或 (|)**：倾向于变 1（白化效应）。参与运算的数越多，结果越趋近于全 1，区分度丧失。
*   **异或 (^)**：它是“不进位的加法”。 0 和 1 的出现概率始终保持 50%，能够最大程度地保留原始数据的随机分布特征。

### B. 极高的敏感度（雪崩效应）

异或是对**“差异”**最敏感的运算。只要输入的任意一个二进制位发生翻转，输出结果的对应位必然翻转。它不会像加法那样被进位掩盖，也不会像与运算那样被 0 掩盖。

### C. 与加法的互补性（正交性）

*   **加法**：依赖进位。容易出现 `1+4 = 2+3 = 5` 的碰撞。
*   **异或**：完全忽略进位。`1^4 = 5`, `2^3 = 1`。

> **结论**：加法和异或在数学性质上是“正交”的（垂直的）。同时骗过这两个运算的概率极低。

