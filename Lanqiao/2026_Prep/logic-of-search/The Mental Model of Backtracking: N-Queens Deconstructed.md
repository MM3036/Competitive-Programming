# 算法笔记：回溯法与八皇后 (Backtracking & N-Queens) 👑

## 1. 核心思维：降维打击 📉

初学者容易将八皇后看作 **64 个格子的二叉树决策**（每个格子放或不放），导致深度过大 ($2^{64}$)。
**高效解法**利用了“每行必有一个皇后”的约束，将问题转化为：

> 💡 **“每一行，我要把皇后放在第几列？”**

* **数据结构**：从二维数组 `board[8][8]` 简化为一维数组 `record[8]`。
* **状态定义**：`record[i] = j` 表示：第 `i` 行的皇后放在了第 `j` 列。
* **深度优化**：决策树深度由 64 层压缩至 **8 层**。

---

## 2. 回溯算法的三大基石 🧱

算法的本质是在一棵决策树上进行遍历，包含三个维度：

### (1) 纵向是进度 (Progress) —— 递归深度
* **含义**：把大问题拆解成多少个小步骤？
* **对应代码**：`dfs(row)` 中的 `row` 参数。
* **原则**：**一步一进度**。八皇后问题中，处理完一行算一步，进度一共 8 步。

### (2) 横向是可能 (Possibilities) —— 解空间广度
* **含义**：当前这一步，我有几种选择？
* **对应代码**：`for col in range(8)`。
* **逻辑**：尝试当前行的所有可能列。

### (3) 剪枝保驾护航 (Pruning) —— 约束函数
* **含义**：在进入某种可能之前，先判断是否“必死”。
* **对应代码**：`if is_valid(row, col)`。
* **核心逻辑**：**不要等撞了南墙才回头，看到墙就直接跳过 (continue)。**

---

## 3. 算法哲学的三个境界 🧘‍♂️

1.  **境界一：盲目试错 (Brute Force)** ❌
    * 不管冲不冲突，先放满了再说，最后再检查。效率极低。

2.  **境界二：提前剪枝 (Pruning)** ✅
    * > **"尽量不要用回溯去试错，要提前剪枝。"**
    * 利用 `check` 函数，把错误的路径扼杀在摇篮里，只走有希望的路。

3.  **境界三：回溯的真谛 (True Backtracking)** 🚀
    * > **"回溯只处理还有没有其他情况。"**
    * 回溯的作用主要有两个：
        1.  **处理死路**：当前路径虽然合法，但在未来走到了死胡同，必须退回。
        2.  **寻找全解**：当前路径成功了，但我要寻找平行宇宙中的**所有其他解法**。

---

## 4. 关键难点：显式回溯 vs 隐式回溯 🔄

为什么有的回溯题需要写 `pop()` 或 `used[i] = False`，而八皇后不需要？

| 特性 | 本题 (1D数组八皇后) | 全排列 / 迷宫 / 2D矩阵 |
| :--- | :--- | :--- |
| **资源类型** | **独享资源** (Exclusive) | **共享资源** (Shared) |
| **解释** | 第 `row` 层只修改 `record[row]`，不碰别人的位置。 | 每一层都可能修改同一个 `board[x][y]` 或 `used` 数组。 |
| **回溯方式** | **覆盖 (Overwrite)**<br>下一次循环的赋值直接抹去旧值。 | **还原 (Restore)**<br>必须手动撤销修改，否则下一层会读到脏数据。 |
| **代码特征** | ❌ 不需要 `record[row] = 0` | ✅ **必须写** `used[i] = False` |

---

## 5. 标准代码模板 (Python) 💻

```python
# record[i] 表示第 i 行的皇后放在了第几列
record = [0] * 8 
ans = 0

def is_valid(row, col):
    for i in range(row):
        # 1. 检查列冲突
        # 2. 检查对角线冲突 (行距 == 列距)
        if record[i] == col or abs(row - i) == abs(col - record[i]):
            return False
    return True

def dfs(row):
    global ans
    # 【终局判断】
    if row == 8:
        ans += 1
        return 

    # 【横向遍历可能性】
    for col in range(8):
        # 【剪枝：先判断，再动手】(Guard Clause)
        if is_valid(row, col):
            
            # 1. 尝试：记录当前选择
            record[row] = col 
            
            # 2. 递归：带着这个选择，推进到下一行 (纵向进度)
            dfs(row + 1)
            
            # 3. 回溯：逻辑执行回此处，for循环进入下一轮
            # record[row] 会被下一次的 col 覆盖，实现“隐式回溯”
