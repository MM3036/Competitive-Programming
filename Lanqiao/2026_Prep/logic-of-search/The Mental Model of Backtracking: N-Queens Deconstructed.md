# 算法笔记：回溯法与八皇后 (Backtracking & N-Queens) 👑

## 1. 核心思维：降维打击 📉

初学者容易将八皇后看作 **64 个格子的二叉树决策**（每个格子放或不放），导致深度过大 ($2^{64}$)。
**高效解法**利用了“每行必有一个皇后”的约束，将问题转化为：

> 💡 **“每一行，我要把皇后放在第几列？”**

* **数据结构**：从二维数组 `board[8][8]` 简化为一维数组 `record[8]`。
* **状态定义**：`record[i] = j` 表示：第 `i` 行的皇后放在了第 `j` 列。
* **深度优化**：决策树深度由 64 层压缩至 **8 层**。

---

## 2. 回溯算法的三大基石 🧱

算法的本质是在一棵决策树上进行遍历，包含三个维度：

### (1) 纵向是进度 (Progress) —— 递归深度
* **含义**：把大问题拆解成多少个小步骤？
* **对应代码**：`dfs(row)` 中的 `row` 参数。
* **原则**：**一步一进度**。八皇后问题中，处理完一行算一步，进度一共 8 步。

### (2) 横向是可能 (Possibilities) —— 解空间广度
* **含义**：当前这一步，我有几种选择？
* **对应代码**：`for col in range(8)`。
* **逻辑**：尝试当前行的所有可能列。

### (3) 剪枝保驾护航 (Pruning) —— 约束函数
* **含义**：在进入某种可能之前，先判断是否“必死”。
* **对应代码**：`if is_valid(row, col)`。
* **核心逻辑**：**不要等撞了南墙才回头，看到墙就直接跳过 (continue)。**

---

## 3. 算法哲学的三个境界 🧘‍♂️

1.  **境界一：盲目试错 (Brute Force)** ❌
    * 不管冲不冲突，先放满了再说，最后再检查。效率极低。

2.  **境界二：提前剪枝 (Pruning)** ✅
    * > **"尽量不要用回溯去试错，要提前剪枝。"**
    * 利用 `check` 函数，把错误的路径扼杀在摇篮里，只走有希望的路。

3.  **境界三：回溯的真谛 (True Backtracking)** 🚀
    * > **"回溯只处理还有没有其他情况。"**
    * 回溯的作用主要有两个：
        1.  **处理死路**：当前路径虽然合法，但在未来走到了死胡同，必须退回。
        2.  **寻找全解**：当前路径成功了，但我要寻找平行宇宙中的**所有其他解法**。

---

## 4. 关键难点：显式回溯 vs 隐式回溯 🔄

为什么有的回溯题需要写 `pop()` 或 `used[i] = False`，而八皇后不需要？

| 特性 | 本题 (1D数组八皇后) | 全排列 / 迷宫 / 2D矩阵 |
| :--- | :--- | :--- |
| **资源类型** | **独享资源** (Exclusive) | **共享资源** (Shared) |
| **解释** | 第 `row` 层只修改 `record[row]`，不碰别人的位置。 | 每一层都可能修改同一个 `board[x][y]` 或 `used` 数组。 |
| **回溯方式** | **覆盖 (Overwrite)**<br>下一次循环的赋值直接抹去旧值。 | **还原 (Restore)**<br>必须手动撤销修改，否则下一层会读到脏数据。 |
| **代码特征** | ❌ 不需要 `record[row] = 0` | ✅ **必须写** `used[i] = False` |

---

## 5. 标准代码模板 (Python) 💻

```python
# record[i] 表示第 i 行的皇后，放在了第几列
# 例如 record[0] = 5 表示第0行皇后在第5列
record = [0] * 8 
ans = 0

# 检查函数：判断第 row 行放在 col 列，是否安全
# 只需要检查 0 到 row-1 行（前面的行）
def is_valid(row, col):
    for i in range(row):
        # i 是之前的行号，record[i] 是之前的列号
        previous_col = record[i]
        
        # 1. 检查列冲突：如果我们想放的 col 和之前某行的 previous_col 一样
        if previous_col == col:
            return False
            
        # 2. 检查对角线冲突：行距 == 列距 (形成等腰直角三角形)
        # abs(当前行 - 之前行) == abs(当前列 - 之前列)
        if abs(row - i) == abs(col - previous_col):
            return False
            
    return True

def dfs(row):
    global ans
    
    # 【终局判断】
    # 如果 row 能够走到 8，说明 0-7 行都已经成功放好了皇后
    if row == 8:
        ans += 1
        return

    # 【遍历选择】
    # 在当前这一行 (row)，尝试每一列 (0 到 7)
    for col in range(8):
        # 【前置剪枝】只有在这个位置是安全的（不攻击之前的皇后），才往下走
        if is_valid(row, col):
            # 记录：第 row 行选了 col 列
            record[row] = col
            
            # 递归：搞定下一行
            dfs(row + 1)
            
            # 【回溯】
            # 这里其实不需要显式写 record[row] = 0
            # 因为下一轮循环的 record[row] = new_col 会自动覆盖旧值
            # 且回溯回去后，row 变小了，刚才那个 record[row] 的值就被这一层的逻辑“遗忘”了

# 启动
import time
start = time.time()
dfs(0)
end = time.time()
print(f"八皇后共有 {ans} 种解法")
print(f"耗时: {end - start:.6f} 秒")
