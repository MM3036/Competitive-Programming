这是一份将原稿中的英文表述全部替换为中文、且保留了专业术语准确性的修改版本：

---

# 03. 迷宫 DFS：核心逻辑与优化笔记

**摘要：** 本文记录了在解决二维迷宫路径问题时，从“暴力模拟”转向“算法思维”的五个关键技术点。重点在于理解递归堆栈、变量隔离以及回溯的本质。

### 1. 方向数组：工程化思维
在处理二维网格的上下左右移动时，应避免编写四个冗余的 `if-else` 语句。

*   **代码模式：**
    定义一个包含偏移量的列表 `options = [(0, 1), (1, 0), (0, -1), (-1, 0)]`。
*   **设计原理：**
    配合 Python 的**元组解包**语法 `for dx, dy in options`，可以在一个循环内尝试所有可能的移动方向。
*   **优势：**
    符合 **DRY（不要重复代码）原则**，逻辑高度统一，且具备良好的扩展性（例如若需改为八方向移动，只需修改数组定义）。

### 2. 路径不可变性：局部变量隔离
在记录路径时，利用递归函数的“局部变量隔离”特性，可以避开复杂的手动回溯操作。

*   **核心代码：** `dfs(x, y, path + [(x, y)])`
*   **核心机制：**
    *   **直接修改（不推荐）：** 使用 `append` 会修改堆内存中同一个列表。回溯时必须手动执行 `pop`，否则会污染父层级的路径数据。
    *   **路径加和（推荐）：** 每次递归调用时，系统会在内存中创建一个全新的列表副本传给下一层。
*   **深度洞察：**
    每一层递归都持有独立的路径副本，互不干扰。这相当于游戏中的**“自动存档”**机制：无论下一层如何折腾，当前层的“存档”始终保持原样。

### 3. 边界检查：门卫机制
所有的合法性检查应在进入递归之前（或递归开头）统一处理，形成一套严密的“门卫”逻辑。

*   **逻辑顺序至关重要：**
    必须利用**短路求值**（Short-circuit evaluation）特性：先判断坐标是否越界，再访问迷宫数组的值。
    ```python
    # 正确顺序：先检查 x, y 是否在界内，再检查 maze[x][y] 的值
    if 0 <= x < N and 0 <= y < M and maze[x][y] == 0:
        pass
    ```

### 4. 回溯的本质：是状态撤销，而非物理折返
理解回溯（Backtracking）的物理动作不是“走回头路”，而是**“时光倒流”**。

*   **核心概念：**
    *   **前行：** 是物理上的移动，表现为向下进入更深一层的递归。
    *   **归位：** 是函数的 `return` 行为，表现为**栈帧（Stack Frame）**的弹出。
*   **瞬间位移：**
    当遇到死胡同导致函数执行完毕时，程序控制流会直接跳回到上一层函数的调用点。此时，该层级的变量（包括坐标 x, y）依然保持着进入死胡同前的状态。你不需要手动“走”回来，你是直接在上一层**“醒来”**。
*   **状态复原（三明治结构）：**
    *   **进入前：** `maze[x][y] = 2`（标记为已访问）。
    *   **离开后：** `maze[x][y] = 0`（还原为可通行）。
    这一步是为了确保其他路径在探索时，不会被之前死胡同留下的标记所误导。

### 5. 可视化：通过日志验证逻辑
算法不应是黑盒，应善用打印输出来辅助验证逻辑。

*   **具体操作：**
    在**基准情形**（即到达终点时）打印完整的 `path` 列表。
*   **目的：**
    不要只输出路径总数。通过打印坐标列表，能帮助大脑建立**搜索树的视觉模型**，直观地观察每一次成功的搜索路径，验证你的路径构造逻辑是否严谨。
```python
  # 地图数据: 0=路, 1=墙
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 1, 0]
]

# 方向数组: 右, 下, 左, 上
# 使用元组解包 (Tuple Unpacking) 简化逻辑
options = [(0, 1), (1, 0), (0, -1), (-1, 0)]
ans = 0

def dfs(r, c, path):
    global ans
    
    # --- 1. Base Case: 到达终点 ---
    if r == 4 and c == 4:
        ans += 1
        print(f'Path {ans}: {path}')
        return

    # --- 2. Mark (进门标记) ---
    # 标记当前点为 2 (已访问)，防止回头死循环
    maze[r][c] = 2

    # --- 3. Explore (循环尝试) ---
    for dx, dy in options:
        x = r + dx
        y = c + dy
        
        # [构造思维]: 先检查，再递归
        # 必须先检查越界，再查 maze 值，否则会报错 IndexError
        if 0 <= x < 5 and 0 <= y < 5:
            if maze[x][y] == 0:
                # [关键技巧]: path + new_node 生成新列表，无需回溯 path
                dfs(x, y, path + [(x, y)])
    
    # --- 4. Unmark (回溯清理) ---
    # 离开当前格前，恢复现场，允许其他路径再次访问此地
    maze[r][c] = 0

# Start Logic
print("Start exploring...")
# 初始路径包含起点
dfs(0, 0, [(0, 0)])
print(f"Total paths found: {ans}")
