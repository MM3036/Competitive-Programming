# 算法笔记：DFS 与 最优性剪枝 - 核心思路

## 2. 核心思路
本题使用了 **深度优先搜索 (DFS)** 结合 **回溯 (Backtracking)** 和 **剪枝 (Pruning)** 策略，将分配过程抽象为一棵决策树。

### 关键机制
1.  **树形遍历 (Tree Traversal)**：
    * `Level (纵向)`：代表第 n 个员工（递归的层级）。
    * `Branch (横向)`：代表当前员工尝试选择第 i 个工程（循环的次数）。

2.  **可行性剪枝 (Feasibility Pruning)**：
    * 利用 `check` 函数、`visited` 数组或 **位运算 (Bitmask)** 判断当前工程是否已被占用。
    * **逻辑**：如果冲突，直接 `continue` 跳过，不产生新的递归分支。

3.  **最优性剪枝 (Optimality Pruning)**：
    * 维护一个全局变量 `min_cost` 记录当前找到的最小花费。
    * **逻辑**：在搜索过程中，如果 `current_cost >= min_cost`，说明这条路即使走到底也不可能比已知结果更优。
    * **动作**：直接 `return`（回溯），切断整个分支，大幅节省计算量。

### 💡 特别补充：正无穷大 `float('inf')`
在寻找“最小值”的问题中，初始化变量通常使用正无穷大。

* **代码写法**：
    ```python
    min_cost = float('inf')
    ```
* **核心作用**：**确保更新**。
    * `float('inf')` 在数学逻辑上大于任何有限的实数。
    * 当程序第一次找到**任何**一条完整的合法路径（假设花费为 100）时，`100 < float('inf')` 恒成立。
    * 这保证了我们的 `min_cost` 能够被第一个有效解成功覆盖，之后再用这个 100 去剪枝后续更贵的路径。
* **对比人工上界**：
    * 如果你设 `min_cost = 40`（人工估计），虽然剪枝更狠，但如果实际最优解是 45，程序就会输出错误结果（因为它认为没找到比 40 小的）。
    * 使用 `float('inf')` 是最安全、标准的做法。
