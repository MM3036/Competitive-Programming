# 5x5_Gomoku_DFS_Logic.md

## 1. 题目背景 (Problem Description)

**题目大意：**
在一块 $5 \times 5$ 的棋盘上，小蓝（持白棋，先手）和小桥（持黑棋，后手）进行五子棋对弈。
- 棋盘共有 25 个格子。
- 由于白棋先手，最终满棋盘时，白棋占 13 格，黑棋占 12 格。
- **目标：** 计算有多少种不同的棋局情况，使得棋盘被下满时，没有任何一方在横线、竖线或斜线上形成连续的五个同色棋子（即平局）。

---

## 2. 核心思维模型：从“平面”到“立体”

### 问题的本质：状态空间树 (State Space Tree)
解决此问题不能依靠简单的多层循环，而应将其建模为一棵**深度为 25 层的递归树**。

*   **深度 (Depth):** 25 层，每一层对应棋盘上的一个坐标索引（0-24）。
*   **分支 (Branch):** 每个节点延伸出两个分支——放置“白棋”或“黑棋”。
*   **遍历方式:** 深度优先搜索（DFS）。像一只蚂蚁，按照“一条路走到黑，撞墙（不合法或触底）再回头”的规则遍历整棵树。

---

## 3. 关键算法洞察 (Core Insights)

### A. 回溯的本质：清理现场 (State Restoration)
**顿悟：** 无论路径是否可行，在退出当前函数层级前必须复原状态。
- **原理：** 整个搜索过程共用同一个棋盘数组 `board`（为了节省内存）。
- **操作：** `board[idx] = 0`。
- **意义：** 这不仅仅是擦除，更是为了保证“兄弟分支”之间的独立性。如果不复原，后续的分支会读到之前尝试留下的“幽灵棋子”，导致逻辑崩溃。

### B. 剪枝的时机：前置判断 (Pre-check Pruning)
**顿悟：** 必须在“下潜”进入下一层递归前进行判断，而不是等放完子再后悔。
- **原理：** 最小化无效计算。
- **操作：** 在落子前一刻检查：
    1.  **数量约束：** 剩余的格子是否还够凑齐 13 个白棋或 12 个黑棋？
    2.  **胜负约束：** 如果这一步落子会导致某方达成“五连珠”，则直接剪断该分支，不再向下递归。

---

## 4. 标准 DFS 执行流 (Standard Workflow)

一个严谨的 DFS 函数体应包含以下四个明确阶段：

| 阶段 | 逻辑位置 | 核心操作 | 作用 |
| :--- | :--- | :--- | :--- |
| **1. 终局判定 (Base Case)** | 函数最开头 | `if idx == 25` | 宣告路径走通，`ans += 1`，执行 `return`。 |
| **2. 可行性预判** | 递归调用前 | 检查剩余棋子数是否达标 | **数量剪枝**，避免无效搜索。 |
| **3. 尝试与验证** | 尝试放置棋子 | 落子 -> `check_win()` | **胜负剪枝**。若成五子则不进入 `dfs(idx + 1)`。 |
| **4. 回溯复原** | 递归调用后 | `board[idx] = 0` | 抹除当前痕迹，迎接下一个分支尝试。 |

---

## 5. 正确答案与结论 (Final Answer)
 
```python

# 全局变量
board = [0] * 25  # 一维数组模拟 5x5 棋盘
ans = 0           # 记录平局数量

# 辅助函数：快速检查刚才落下的子是否导致了连珠
# 只要检查经过 idx 的行、列、对角线即可
def check_is_win(idx, color):
    r, c = idx // 5, idx % 5
    
    # 1. 检查行
    # 这一行的起点是 r * 5
    row_start = r * 5
    if all(board[row_start + i] == color for i in range(5)):
        return True
        
    # 2. 检查列
    # 这一列的起点是 c, 每次 +5
    if all(board[c + i*5] == color for i in range(5)):
        return True
        
    # 3. 检查主对角线 (只有当 idx 在对角线上时才查)
    # 主对角线上的点满足 r == c (0, 6, 12, 18, 24)
    if r == c:
        if all(board[i*6] == color for i in range(5)):
            return True

    # 4. 检查副对角线
    # 副对角线上的点满足 r + c == 4 (4, 8, 12, 16, 20)
    if r + c == 4:
        if all(board[4 + i*4] == color for i in range(5)):
            return True
            
    return False

def dfs(idx, white_cnt, black_cnt):
    global ans
    
    # --- 1. 终局判断 (Base Case) ---
    if idx == 25:
        # 能走到这里，说明中间没有任何人赢，且棋盘填满了
        ans += 1
        return

    # --- 2. 剪枝前置 (Pruning) ---
    # 如果剩余的格子不够填满白棋或黑棋，直接放弃
    remaining_cells = 25 - idx
    if remaining_cells < (13 - white_cnt) or remaining_cells < (12 - black_cnt):
        return

    # --- 3. 递归与回溯 (The Loop) ---
    
    # 【选项 A：尝试放白棋】
    if white_cnt < 13:
        board[idx] = 1 # 落子
        # 关键逻辑：只有当“这一步没赢”时，才允许继续往下走
        # 如果这一步赢了，就不递归了（剪枝），因为我们要的是平局
        if not check_is_win(idx, 1):
            dfs(idx + 1, white_cnt + 1, black_cnt)
        board[idx] = 0 # 【回溯：打扫现场，消灭幽灵棋子】

    # 【选项 B：尝试放黑棋】
    if black_cnt < 12:
        board[idx] = 2 # 落子
        if not check_is_win(idx, 2):
            dfs(idx + 1, white_cnt, black_cnt + 1)
        board[idx] = 0 # 【回溯：打扫现场】

# --- 主程序 ---
# 小蓝（白棋）先手，需要下 13 个
# 小桥（黑棋）后手，需要下 12 个
print("正在计算中，请稍候... (大约需要几秒钟)")
dfs(0, 0, 0)
print(f"满足条件的平局总数是: {ans}")
 
 ```
**最终平局方案数：**
### `55374`

> **性能提示：** 
> 纯暴力搜索共有 $2^{25} \approx 3.3 \times 10^7$ 种情况。通过在每一层实时进行“五连珠”检查和“棋子剩余数量”检查，搜索空间被极大地压缩，程序可在数秒内得出结果。

---
