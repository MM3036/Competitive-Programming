# 初始化：5x5 棋盘，使用一维数组模拟 (0-24)
# 0 表示空，1 表示白棋，2 表示黑棋
board = [0] * 25 
ans = 0

# 辅助函数：检查是否有人赢了（是否有5连珠）
def check_winner():
    # 检查行 (5行, 每行起点是 0, 5, 10, 15, 20)
    for r in range(0, 25, 5):
        if board[r] != 0 and \
           board[r] == board[r+1] == board[r+2] == board[r+3] == board[r+4]:
            return True
            
    # 检查列 (5列, 每列起点是 0, 1, 2, 3, 4)
    for c in range(5):
        if board[c] != 0 and \
           board[c] == board[c+5] == board[c+10] == board[c+15] == board[c+20]:
            return True
            
    # 检查主对角线 (只有一条：0, 6, 12, 18, 24)
    if board[0] != 0 and \
       board[0] == board[6] == board[12] == board[18] == board[24]:
        return True
        
    # 检查副对角线 (只有一条：4, 8, 12, 16, 20)
    if board[4] != 0 and \
       board[4] == board[8] == board[12] == board[16] == board[20]:
        return True
        
    return False

def dfs(idx, white_cnt):
    global ans
    
    # --- 1. 终止条件 (走到死) ---
    # 如果白棋超过13个，剪枝（不可能发生，因为后面限制了，但作为保险）
    if white_cnt > 13:
        return

    # 如果格子都遍历完了 (0-24 都决定好了)
    if idx == 25:
        # 必须正好 13 个白棋 (剩下的自然是 12 个黑棋)
        if white_cnt == 13:
            # --- 2. 检查结果 (回头看) ---
            # 如果没人赢，那就是平局，计数 +1
            if not check_winner():
                ans += 1
        return

    # --- 3. 递归选择 (分岔路) ---
    
    # 剩余的格子数量
    remaining_cells = 25 - idx
    # 需要填补的白棋数量
    needed_white = 13 - white_cnt
    
    # 剪枝优化：如果剩下的格子全放白棋都不够13个，就别搜了
    if remaining_cells < needed_white:
        return

    # 选择一：在这个格子放白棋 (1)
    if white_cnt < 13:
        board[idx] = 1
        dfs(idx + 1, white_cnt + 1)
        # 回溯 (Backtrack)：恢复现场，这一步非常重要！
        board[idx] = 0 

    # 选择二：在这个格子放黑棋 (2)
    # 只要不放白棋，这里就必须是黑棋（因为要求填满）
    board[idx] = 2
    dfs(idx + 1, white_cnt)
    # 回溯
    board[idx] = 0

# 开始运行
dfs(0, 0)
print(f"平局的情况共有: {ans} 种")
