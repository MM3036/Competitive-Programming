小明所在的魔法世界有 $N$ 个城市，编号为 $1$ 到 $N$。这些城市之间通过 $M$ 条魔法道路相连。注意，魔法道路是双向的（从 A 到 B 和从 B 到 A 距离一样）。有时候，两个城市之间可能修建了多条道路，但小明肯定只会选择最近的那一条。现在小明想知道，在所有魔法道路都畅通的情况下，从城市 $A$ 到城市 $B$ 的最短距离是多少？【输入格式】第一行包含两个整数 $N$ 和 $M$，分别表示城市的数量和道路的数量。($1 \le N \le 100$, $1 \le M \le 1000$) —— 看到 N 小于 500，放心用 Floyd！接下来 $M$ 行，每行包含三个整数 $u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条长度为 $w$ 的双向道路。最后一行包含两个整数 $start, end$，表示小明想询问的起点和终点。【输出格式】输出一个整数，表示 $start$ 到 $end$ 的最短距离。如果两个城市无法连通（走不到），请输出 -1。

# 设定无穷大，方便后续比较
INF = float('inf')

# 1. 接收 N 和 M
# input().split() 拿到的是字符串列表，需要 map 成整数
line1 = input().split()
if not line1: exit() # 防止空输入报错
N, M = int(line1[0]), int(line1[1])

# 2. 初始化邻接矩阵 (关键步骤！)
# 开 N+1 的大小，这样下标 1 就是 1 号城市，0 号下标这行我们就弃用
dist = [[INF] * (N + 1) for _ in range(N + 1)]

# 初始化：自己到自己距离为 0
for i in range(1, N + 1):
    dist[i][i] = 0

# 3. 读入 M 条道路信息
for _ in range(M):
    u, v, w = map(int, input().split())
    
    # 【坑点防御 1】处理重边
    # 题目说“可能有几条路”，我们只保留最短的那条
    # 比如输入 1 2 10 和 1 2 5，我们要保留 5
    # 【坑点防御 2】双向边
    # u 到 v 和 v 到 u 都要更新
    dist[u][v] = min(dist[u][v], w)
    dist[v][u] = min(dist[v][u], w)

# 4. 读入起点和终点
start_node, end_node = map(int, input().split())

# ==========================================
# 5. Floyd 核心算法 (背诵部分)
# ==========================================
# 第一层 k：枚举中转站 (必须在最外层！)
for k in range(1, N + 1):
    # 第二层 i：枚举起点
    for i in range(1, N + 1):
        # 优化：如果起点 i 到中转站 k 都不通，那 k 肯定没法帮 i 中转
        # 这一行不是必须的，但在稀疏图中能快一点点
        if dist[i][k] == INF: continue
            
        # 第三层 j：枚举终点
        for j in range(1, N + 1):
            # 状态转移方程：松弛操作
            # 尝试把 k 插入 i 和 j 中间
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]

# ==========================================

# 6. 输出结果
# 如果还是无穷大，说明路不通，输出 -1
if dist[start_node][end_node] == INF:
    print(-1)
else:
    print(dist[start_node][end_node])
