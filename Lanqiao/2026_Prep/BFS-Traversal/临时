import sys
import collections
import heapq

# 1. 快速读取输入
# 将所有输入一次性读入内存，然后用迭代器按顺序取
data = map(int, sys.stdin.read().split())
iterator = iter(data) # 把它变成迭代器，方便 next() 调用

try:
    N = next(iterator)
    M = next(iterator)
except StopIteration:
    sys.exit(0)

# 2. 建图
graph = collections.defaultdict(list)
# [Bug Fix]: 这里是 M (边数)，不是 N (点数)
for _ in range(M):
    u = next(iterator)
    v = next(iterator)
    w = next(iterator)
    graph[u].append((v, w))

def dijkstra(n, graph, start):
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    pq = []
    
    # [Bug Fix]: 必须把距离放前面！(0, start)
    heapq.heappush(pq, (0, start))
    
    while pq:
        # [Bug Fix]: 拿出来的也要对应：先距离 d，后节点 u
        d, u = heapq.heappop(pq)
        
        # Fail Fast
        if d > dist[u]:
            continue
            
        # [Bug Fix]: 遍历 graph[u]，而不是 graph
        for v, w in graph[u]:
            if d + w < dist[v]:
                # [Bug Fix]: 是赋值 =，不是判断 ==
                dist[v] = d + w
                # 这里 push 顺序是对的，保持一致
                heapq.heappush(pq, (dist[v], v))
                
    return dist

# 3. 运行算法并接收结果
# [Bug Fix]: 接收返回值
final_dists = dijkstra(N, graph, 1)

# 4. 输出逻辑
target_dist = final_dists[N]

# 如果是 inf 说明不可达
if target_dist == float('inf'):
    print(-1)
else:
    print(target_dist)
