# LeetCode 542. 01 矩阵 (01 Matrix) - 逆向多源 BFS

## Problem Statement

Given an `m x n` binary matrix `mat`, return *the distance of the nearest `0` for each cell*.

The distance between two adjacent cells is `1`.

---

## 1. 核心考点

- **逆向思维 (Inverse Thinking)**: 
  - 题目直观要求是“1 找最近的 0”，但在算法实现上，必须转化为“**0 去淹没所有的 1**”。
- **多源 BFS (Multi-Source BFS)**: 
  - 将所有目标点（0）视为同时爆发的源头，建立距离场。
- **状态压缩**: 
  - 如何仅用一个矩阵同时存储“距离”和“访问状态” (Visited)。

## 2. 解题思路 (物理模型：等高线/洪水倒灌)

**核心误区**: 不要试图从每个“旱地”(1) 出发去搜索“水源”(0)。因为旱地是未知的，而水源是已知的。
**物理法则**: 信息（距离）必须从“已知”流向“未知”。

### 模型构建:
1.  **海平面**: 将所有 `0` 视为海拔为 0 的海平面。
2.  **山地**: 将所有 `1` 视为未知的山地（海拔待定）。
3.  **洪水上升**: BFS 的过程就是海平面上升的过程。第一圈波浪触及的地方海拔为 1，第二圈为 2，以此类推。

### 算法步骤:
1.  **预处理 (Initialization)**:
    - 创建一个 `dist` 矩阵（建议复用新矩阵或在原矩阵操作），初始化为 `-1`。**`-1` 代表“未探索区域”**。
    - 遍历网格：
      - 遇到 `0` (水源): 将其距离设为 `0`，并入队。
      - 遇到 `1`: 保持 `-1` 不变。
2.  **BFS 扩散 (Propagation)**:
    - 队列弹出 `(r, c)`。
    - 扫描四周 `(nr, nc)`。
    - **核心判断**: 只要 `dist[nr][nc] == -1`，说明这是洪水第一次到达该地块（即最短路径）。
    - **状态更新**: `dist[nr][nc] = dist[r][c] + 1`，并入队。

## 3. 复杂度对比 (为什么不能从 1 出发？)

假设地图大小为 $N \times M$。

| 方法 | 描述 | 复杂度 | 结果 |
| :--- | :--- | :--- | :--- |
| **正确做法 (从 0 扩散)** | 所有 0 同时入队，每个节点只进出队列 1 次 | $O(N \times M)$ | ✅ AC |
| **错误做法 (从 1 搜索)** | 对每一个 1 都进行一次 BFS 找 0 | 最坏 $O((N \times M)^2)$ | ❌ TLE |

> **注意**: 当 $N,M=1000$ 时，错误做法的运算量达到 $10^{12}$，必导致超时。

## 4. 代码实现 (Python 标准模板)

此模板展示了如何通过一个矩阵实现极致的内存优化：`dist` 矩阵既存储结果，又充当 `visited` 数组。

```python
from collections import deque
from typing import List

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        R, C = len(mat), len(mat[0])
        # dist 矩阵：既存储距离，又充当 visited 数组
        # -1 表示未访问/无穷大
        dist = [[-1] * C for _ in range(R)]
        q = deque()
        
        # Step 1: 初始化 (寻找所有源头)
        for r in range(R):
            for c in range(C):
                if mat[r][c] == 0:
                    dist[r][c] = 0   # 源头距离已知为 0
                    q.append((r, c)) # 源头入队
                # 如果是 1，dist 保持 -1，等待被更新
        
        # Step 2: 多源 BFS 引擎
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        while q:
            r, c = q.popleft()
            
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                
                # 边界检查
                if 0 <= nr < R and 0 <= nc < C:
                    # 核心逻辑：只处理未被淹没的区域 (-1)
                    if dist[nr][nc] == -1:
                        dist[nr][nc] = dist[r][c] + 1  # 距离推导公式
                        q.append((nr, nc))             # 加入下一轮扩散
        
        return dist
```

## 5. 关键总结 (Key Takeaways)

1.  **源点的定义**: 在 BFS 中，“源”不仅是起跑线，更是**信息的持有者**。这道题里，0 持有信息（距离=0），所以它是源。
2.  **三位一体优化**: 
    - `dist` 矩阵完成三件事：存储最终结果、记录是否访问过(`-1`)、存储中间状态。
3.  **区别于“腐烂橘子”**:
    - **腐烂橘子**: 模拟过程（求最后的时间）。
    - **01 矩阵**: 测绘过程（求所有点的距离）。
    - **相同点**: 底层逻辑完全一致，都是 **多源入队 -> 层序遍历**。

```
