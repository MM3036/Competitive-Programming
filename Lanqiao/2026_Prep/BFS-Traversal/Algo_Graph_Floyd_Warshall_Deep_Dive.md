# 算法学习笔记：Floyd-Warshall (弗洛伊德算法)

## 一、 核心知识点

### 1. 算法定义
Floyd 算法是一种用于解决任意两点间最短路径（All-Pairs Shortest Path, APSP）的动态规划算法。它能够处理有向图或无向图，且允许图中存在负权边（但不允许存在负权环）。

### 2. 数学原理：动态规划 (DP)
*   **状态定义**：$dist[i][j]$ 表示从节点 $i$ 到节点 $j$ 的最短路径长度。
*   **松弛操作 (Relaxation)**：基于三角不等式原理，尝试引入中转节点 $k$，若经过 $k$ 的路径比原路径更短，则更新距离。
*   **状态转移方程**：
    $$dist[i][j] = \min(dist[i][j], \ dist[i][k] + dist[k][j])$$
*   **时间复杂度**：$O(N^3)$。适用于节点规模较小的情况（通常 $N \le 500$）。
*   **空间复杂度**：$O(N^2)$，使用邻接矩阵存储。

### 3. 算法流程
通过三层循环遍历：
1.  **第一层 (k)**：枚举中间节点（阶段），代表“允许经过前 $k$ 个节点中转”。
2.  **第二层 (i)**：枚举起点。
3.  **第三层 (j)**：枚举终点。

---

## 二、 易错点与实现细节

### 1. 循环顺序（至关重要）
*   **规则**：中转节点 $k$ 必须置于最外层循环。
*   **原理**：DP 的状态依赖性。计算“允许经过前 $k$ 个点”的最短路时，必须基于“允许经过前 $k-1$ 个点”的最优解。若 $k$ 在内层，会导致状态更新不完全，无法利用已计算的复杂路径。

### 2. 矩阵初始化
*   **自环 ($i=j$)**：必须初始化为 0。
*   **不可达 ($i \neq j$)**：必须初始化为 **正无穷大** (`float('inf')` 或 `0x3f3f3f3f`)。
*   **错误警示**：不可使用 `-1` 初始化。因为算法核心是 `min` 操作，`-1` 会被误判为比任何正权路径都短的“最优解”，导致逻辑崩溃。这体现了算法的鲁棒性要求：初始值必须大于任何可能的合法路径之和。

### 3. 图的构建与读入
*   **重边处理**：两点间可能存在多条边。读入时应保留最小值，而非直接赋值覆盖。
    *   代码逻辑：`graph[u][v] = min(graph[u][v], w)`
*   **双向边处理**：对于无向图，更新 $u \to v$ 时必须同步更新 $v \to u$。
*   **节点索引**：若题目节点编号从 1 开始，建议开辟 $N+1$ 大小的数组，避免索引偏移带来的混淆。

---

---

## 三、 题目 (Practice Problems)
小明所在的魔法世界有 $N$ 个城市，编号为 $1$ 到 $N$。这些城市之间通过 $M$ 条魔法道路相连。
注意，魔法道路是双向的（从 A 到 B 和从 B 到 A 距离一样）。有时候，两个城市之间可能修建了多条道路，
但小明肯定只会选择最近的那一条。现在小明想知道，在所有魔法道路都畅通的情况下，从城市 $A$ 到城市 $B$ 的最短距离是多少？
【输入格式】第一行包含两个整数 $N$ 和 $M$，分别表示城市的数量和道路的数量。($1 \le N \le 100$, $1 \le M \le 1000$) —— 看到 N 小于 500，放心用 Floyd！
接下来 $M$ 行，每行包含三个整数 $u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条长度为 $w$ 的双向道路。
最后一行包含两个整数 $start, end$，表示小明想询问的起点和终点。
【输出格式】输出一个整数，表示 $start$ 到 $end$ 的最短距离。如果两个城市无法连通（走不到），请输出 -1。
3 3
1 2 10
1 3 5
2 3 3
1 2

8
---

## 四、 代码实现 (Code Implementation)

```python
import sys

# 1. 读取所有数据
data = map(int, sys.stdin.read().split())

try:
    N = next(data)
    M = next(data)
except StopIteration:
    exit()

# 【修正1】不要用 map 做变量名，也不要用 -1 初始化
# 初始化邻接矩阵：全部为无穷大
dist = [[float('inf')] * (N + 1) for _ in range(N + 1)]

# 【修正2】对角线初始化为 0 (自己到自己距离为0)
for i in range(1, N + 1):
    dist[i][i] = 0

for _ in range(M):
    u = next(data)
    v = next(data)
    w = next(data)
    
    # 【修正3】处理重边：取最小值
    # 【修正4】双向图：在输入时就同时赋值
    if w < dist[u][v]:
        dist[u][v] = w
        dist[v][u] = w

# Floyd 核心算法
for k in range(1, N + 1):
    for i in range(1, N + 1):
        # 剪枝优化：如果起点到中转站不通，直接跳过
        if dist[i][k] == float('inf'):
            continue
            
        for j in range(1, N + 1):
            # 松弛操作
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]

# 获取询问
start = next(data)
end = next(data)

# 【修正5】输出格式：如果是 inf，题目通常要求输出 -1
ans = dist[start][end]
if ans == float('inf'):
    print(-1)
else:
    print(ans)
```

---

## 五、 Floyd 与 Dijkstra 算法对比

| 维度 | Dijkstra 算法 | Floyd 算法 |
| :--- | :--- | :--- |
| **解决问题** | 单源最短路 (One-to-All) | 多源最短路 (All-to-All) |
| **核心思想** | 贪心策略 (Greedy) | 动态规划 (Dynamic Programming) |
| **负权边** | 不可处理 (贪心假设失效) | 可处理 (只要无负权环) |
| **复杂度** | $O(N^2)$ 或 $O(E \log N)$ (堆优化) | $O(N^3)$ |
| **适用场景** | 稀疏图、点多边少、只需一个起点 | 稠密图、点少 ($N \le 500$)、需任意两点距离 |
| **实现难度** | 较高 (需维护优先队列) | 极低 (四行核心代码) |

---

## 六、 题目复盘与收获

### 1. 从“找路”到“算账”
图论中的路径权值不仅仅代表物理距离，更代表“代价”。Floyd 算法的本质是不断寻找“中转站”来降低总代价。即使路径物理上变长（经过更多节点），只要权值之和变小，即为更优。

### 2. 初始化的哲学
在求最小值的算法中，未知区域必须用“无穷大”占位。这不仅是数学要求，更是程序鲁棒性的体现——防止无效数据干扰有效数据的比较逻辑。

### 3. 三层循环的物理意义
*   **BFS** 是在空间上向外扩散（由近及远）。
*   **Floyd** 是在时间（阶段）上逐步解除限制（从只允许 1 号中转，到允许所有点中转）。
*   $k$ 循环代表了图的连通性从局部到全局的演变过程。

### 4. 鲁棒性思维
在编写代码时，需预判极端情况：
*   图不连通怎么办？（输出 -1 而非 inf）
*   有重边怎么办？（取 min）
这种防御性编程思维对于通过蓝桥杯等竞赛的边缘测试用例至关重要。

## 七、 总结

Floyd 算法是用时间换空间和代码复杂度的典型代表。虽然 $O(N^3)$ 的效率在处理大规模数据时显得笨重，但其简洁的实现和处理多源、负权边的能力，使其在小规模图论问题（尤其是涉及连通性、传递闭包）中具有不可替代的地位。掌握其“动态规划”的本质，比单纯记忆代码模板更为重要。
