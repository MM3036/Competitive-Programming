# 蓝桥杯真题笔记：《四平方和》

## 1. 题目描述

*   **题目名称**：四平方和 (Four Squares)
*   **来源**：2016年蓝桥杯省赛 B组
*   **核心定理**：拉格朗日四平方和定理。任何一个正整数 $N$ 都可以表示为至多 4 个正整数的平方和。若将 0 视为正整数，则 $N = a^2 + b^2 + c^2 + d^2$ ($a, b, c, d$ 为非负整数)。

### 任务要求
给定正整数 $N$ ($N < 5,000,000$)，找到一组 $a, b, c, d$ 满足上述方程。

### 输出限制
1.  **必须满足排序**：$0 \le a \le b \le c \le d$。
2.  **字典序最小**：若存在多组解，需按 $a, b, c, d$ 为联合主键进行排序，输出字典序最小的一组。

### 样例

> 输入：`5`
> 输出：`0 0 1 2`

> 输入：`12`
> 输出：`0 2 2 2`

> 输入：`773535`
> 输出：`1 1 267 838`

---

## 2. 核心知识点与算法思想

### 2.1 复杂度与优化
*   **痛点**：$N$ 高达 $5 \times 10^6$，常规 $O(N^3)$ 枚举会超时（Time Limit Exceeded）。
*   **目标**：将复杂度降低至 $O(N)$ 或接近 $O(N)$。

### 2.2 中途相遇法 (Meet-in-the-middle)
*   **定义**：将大规模搜索问题拆解为两个规模较小的子问题，利用空间换时间。
*   **应用**：
    1.  将 $a, b, c, d$ 分为两组：$(c, d)$ 和 $(a, b)$。
    2.  **预处理 (Pre-computation)**：枚举 $c, d$，将所有可能的 $c^2 + d^2$ 的和及其对应的最小 $c$ 存入表（数组/哈希表）。
    3.  **查表 (Lookup)**：枚举 $a, b$，计算 $Rest = N - a^2 - b^2$，在表中查询 $Rest$ 是否存在。

### 2.3 数据结构选择
*   **数组打表 (Direct Addressing)**：利用数组下标直接代表数值（平方和），实现 $O(1)$ 的极速查询，优于 `bisect` 二分查找 ($O(\log N)$) 和常规 `HashMap`。

### 2.4 字典序与联合主键
*   **含义**：即多级排序。优先比较 $a$，若相同比较 $b$，以此类推。
*   **实现**：通过多层循环从小到大枚举 ($a$ 从 0 开始， $b$ 从 $a$ 开始...)，找到的第一组解即为字典序最小解，无需后续排序。

---

## 3. 学习过程中的关键疑问 (Q&A 归纳)

### 疑问 1：算法的正统性
*   **问题**：这种“打表”和“空间换时间”的方法是否属于投机取巧？
*   **解答**：这是算法竞赛中标准的 **“中途相遇法” (Meet-in-the-middle)**，是解决指数级搜索问题的经典策略，并非投机取巧，而是对计算资源的合理调度。

### 疑问 2：预处理表的逻辑
*   **问题**：表中存储的“5”代表什么？预处理的结构是怎样的？
*   **解答**：表采用 `Index-Value` 结构。
    *   **Index (下标)**：代表 $c^2 + d^2$ 的和（例如 5）。
    *   **Value (值)**：代表构成该和的最小 $c$ 值。
    *   这样设计是为了在枚举 $a, b$ 计算出剩余值后，能立即通过下标判断该值是否可由 $c, d$ 构成。

### 疑问 3：二分查找 (Bisect) 的必要性
*   **问题**：为何不使用 Python 的 `bisect` 库进行二分查找？
*   **解答**：虽然二分查找是优化手段，但在内存足够（$5 \times 10^6$ 个整数）的情况下，**直接寻址（数组下标访问）** 的时间复杂度为 $O(1)$，远快于二分查找的 $O(\log N)$。在极端的竞赛时间限制下，数组直接查表是更优解。

### 疑问 4：术语理解 (字典序与联合主键)
*   **问题**：如何理解“按 $a, b, c, d$ 为联合主键排序”及“字典序最小”？
*   **解答**：
    *   这是数据库与离散数学术语，本质是从左到右逐位比较。
    *   在代码实现上，这对应了循环枚举的顺序。只要保证循环变量 $a, b$ 是从小到大递增的，程序找到的第一个可行解必然满足上述排序要求。这意味着找到解后可直接退出程序，无需遍历所有解。

---

## 4. 参考代码

```python
import sys
import math

# 设置递归深度和输入优化（虽然这题不用递归，但养成好习惯）
sys.setrecursionlimit(2000)

def solve():
    # 读取输入
    try:
        line = sys.stdin.readline()
        if not line:
            return
        N = int(line.strip())
    except ValueError:
        return

    # 1. 空间换时间：预处理 c^2 + d^2
    # 我们用一个列表 cache 来存储某个平方和 val 对应的最小的 c
    # cache[val] = c (如果 val 还没被记录过)
    # 列表索引是平方和的值，最大可能为 N
    
    # 注意：为了节省空间，我们可以只存 c，因为 d = sqrt(val - c^2)
    # 初始化为 -1 表示该和未出现过
    cache = [-1] * (N + 1)
    
    # 限制 c 的范围：c^2 <= N/2 (因为 c <= d，若 c^2 > N/2 则 c > d，这是重复的或者会超出 N)
    # 实际上为了保险和简单，c 枚举到 sqrt(N) 也可以，但 N/2 更优
    # 这里为了处理方便，我们只需保证 c <= d 即可
    
    max_sqrt = int(math.isqrt(N))
    
    # 填充 cache
    # 必须从小到大枚举 c，这样第一次存入 cache[s] 的一定是 c 最小的解
    for c in range(max_sqrt + 1):
        c2 = c * c
        if c2 > N: break
        
        # d 从 c 开始枚举，保证 c <= d
        for d in range(c, max_sqrt + 1):
            s = c2 + d * d
            if s > N:
                break
            
            # 只有当该和 s 第一次出现时才记录 c
            # 这保证了对于同一个 sum，我们取的是字典序最小的 (c, d)
            if cache[s] == -1:
                cache[s] = c

    # 2. 枚举 a 和 b
    # 同理，a 从 0 到 sqrt(N/4) (因为 a <= b <= c <= d)
    # 放宽一点到 sqrt(N) 也没错，只要找到就退
    for a in range(max_sqrt + 1):
        a2 = a * a
        if a2 > N: break
        
        for b in range(a, max_sqrt + 1): # b 从 a 开始，保证 a <= b
            b2 = b * b
            rest = N - a2 - b2
            
            if rest < 0:
                break
            
            # 3. 查表 (Meet-in-the-middle)
            if cache[rest] != -1:
                c = cache[rest]
                # 计算 d
                d = int(math.isqrt(rest - c * c))
                
                # 输出结果并直接结束程序
                print(f"{a} {b} {c} {d}")
                return

# 执行
if __name__ == '__main__':
    solve()
```

---
