# 算法笔记：二分答案模型的变式与对比

## 一、 题目详情 (Problem Descriptions)

### 1. 愤怒的牛 (Aggressive Cows)
*   **来源**：USACO / POJ 2456 / 蓝桥杯模拟
*   **问题描述**：
    农夫约翰建造了一座有 $N$ 间牛舍的小屋，牛舍排在一条直线上，第 $i$ 间牛舍在 $x_i$ 的位置。约翰有 $M$ 头牛，为了防止牛之间互相打斗，他想把这些牛安置在指定的牛舍中。为了降低攻击性，必须使得任意两头牛之间的最小距离尽可能大。
*   **输入格式**：
    第一行包含两个整数 $N, M$。
    接下来 $N$ 行，每行一个整数，表示牛舍坐标 $x_i$。
*   **输出格式**：
    输出一个整数，表示最大的最小距离。
*   **数据范围**：
    $2 \le N \le 10^5$, $0 \le x_i \le 10^9$。

### 2. 跳石头 (Roadblocks / NOIP2015)
*   **来源**：NOIP 2015 提高组 / 洛谷 P2678
*   **问题描述**：
    一年一度的“跳石头”比赛在一条全长为 $L$ 的河道中进行。起点在 $0$，终点在 $L$。河道中间有 $N$ 块岩石，坐标分别为 $d_i$。为了提高比赛难度，组委会计划移走其中的 $M$ 块岩石。目标是：在移除 $M$ 块岩石后，使得起点、终点和剩余岩石中，任意两块相邻岩石之间的最小距离的最大值尽可能大。
*   **输入格式**：
    第一行包含三个整数 $L, N, M$。
    接下来 $N$ 行，每行一个整数，表示岩石坐标 $d_i$。
*   **输出格式**：
    输出一个整数，表示最短跳跃距离的最大值。
*   **数据范围**：
    $0 \le L \le 10^9$, $0 \le N \le 50000$。

### 3. 路标设置 (Roadsigns)
*   **来源**：洛谷 P3853 / 蓝桥杯模拟
*   **问题描述**：
    公路上总长为 $L$ 的路段上，已经设置了 $N$ 个路标，位置分别是 $x_1, x_2, \dots, x_N$（保证 $x_1 = 0, x_N = L$）。主管部门决定在公路上新增最多 $K$ 个路标。
    定义“空旷指数”为：任意两个相邻路标（含新增路标）之间距离的最大值。
    请问，在最多新增 $K$ 个路标的情况下，这个“空旷指数”最小可以是多少？
*   **输入格式**：
    第一行包含三个整数 $L, N, K$。
    第二行包含 $N$ 个整数，表示原有路标坐标。
*   **输出格式**：
    输出一个整数，表示“空旷指数”的最小值。
*   **数据范围**：
    $0 < L \le 10^7$, $0 \le K \le 10^5$。

---

## 二、 核心公式推导：区间切分 (Interval Partitioning)

在《路标设置》一题中，核心难点在于计算“给定一个距离 $D$，将其切分至每段长度不超过 $mid$，需要切几刀（增加几个路标）”。

### 公式
设区间长度为 $dist$，目标最大长度为 $mid$，所需新增路标数为 $need$：
$$need = (dist - 1) \ // \ mid$$
*(注：`//` 表示整除运算)*

### 推导逻辑

1.  **数学定义**：
    我们需要将长度 $dist$ 分成 $k$ 段，使得每段长度 $\le mid$。
    段数 $k = \lceil \frac{dist}{mid} \rceil$ （向上取整）。
    因为切 $k$ 段只需要 $k-1$ 刀，所以路标数 $need = \lceil \frac{dist}{mid} \rceil - 1$。

2.  **编程实现与边界处理**：
    *   **情况 A（整除）**：
        设 $dist=6, mid=3$。理论段数 $6/3=2$，需切 $1$ 刀。
        *   若使用 $dist // mid$，结果为 2（错误）。
        *   若使用 $(dist-1) // mid$，即 $5 // 3 = 1$（正确）。
    *   **情况 B（有余数）**：
        设 $dist=7, mid=3$。理论段数 $\lceil 7/3 \rceil = 3$，需切 $2$ 刀。
        *   若使用 $(dist-1) // mid$，即 $6 // 3 = 2$（正确）。

### 结论
$(dist - 1) // mid$ 是统一处理整除与非整除情况的通用公式，避免了额外的条件判断。

---

## 三、 三题深度横向对比 (Comparative Analysis)

这三道题虽然都属于“二分答案 + 贪心 Check”，但在操作对象、优化目标和二分模版上存在本质区别。

| 维度 | 1. 愤怒的牛 | 2. 跳石头 | 3. 路标设置 |
| :--- | :--- | :--- | :--- |
| **操作动作** | **选择 (Selection)**<br>从 $N$ 个点中选出 $M$ 个 | **移除 (Removal)**<br>移走 $M$ 个点 (保留 $N-M$ 个) | **插入 (Insertion)**<br>在区间内插入 $\le K$ 个点 |
| **优化目标** | **最大化最小值**<br>(Maximize the Minimum) | **最大化最小值**<br>(Maximize the Minimum) | **最小化最大值**<br>(Minimize the Maximum) |
| **二分模版** | **模版 1 (找右边界)**<br>`mid = (l+r+1)//2`<br>`check(mid) ? l=mid : r=mid-1` | **模版 1 (找右边界)**<br>`mid = (l+r+1)//2`<br>`check(mid) ? l=mid : r=mid-1` | **模版 2 (找左边界)**<br>`mid = (l+r)//2`<br>`check(mid) ? r=mid : l=mid+1` |
| **Check 逻辑** | **正向贪心**<br>当前点与上一点距离 $\ge mid$ 则放置。<br>看总数是否 $\ge M$。 | **逆向贪心**<br>当前点与上一点距离 $< mid$ 则移走。<br>看移走数是否 $\le M$。 | **独立计算**<br>遍历每个既定区间，计算需切几刀。<br>看总刀数是否 $\le K$。 |
| **关键变量** | `last_pos`<br>(上一头牛的位置) | `last_pos`<br>(上一块保留石头的位置) | 无关位置<br>只关注区间长度 `graph[i] - graph[i-1]` |
| **起始点策略** | **必选起点**<br>第一头牛定在 $x_0$ 最优 | **必选起点**<br>起点 $0$ 不可移除，从起点后开始判断 | **无关**<br>只关注区间长度，不关注绝对坐标 |
| **总结** | **同构问题**：<br>跳石头与愤怒的牛是同构的，都是在维护“点与点之间的距离下限”。区别在于一个是“拿走不合法的”，一个是“选出合法的”。 | **同构问题**：<br>(同左) | **对偶问题**：<br>路标设置是前两者的对偶。它维护的是“距离的上限”。因此二分的方向完全相反（求最小），Check 的逻辑从“连续依赖”变成了“分段独立”。 |

---

## 四、 参考代码 (Solutions)

### 3. 路标设置 (Roadsigns)

```python
import sys

# 1. 读取输入
input = sys.stdin.read
data = input().split()
iterator = iter(data)

L = int(next(iterator))
N = int(next(iterator))
K = int(next(iterator))

# 读取原有的 N 个路标
graph = [int(next(iterator)) for _ in range(N)]

def check(mid):
    count = 0
    # 2. 遍历所有相邻的区间（Gap）
    # 路标是固定的，区间也是固定的，互不影响
    for i in range(1, N):
        dist = graph[i] - graph[i-1]
        
        # 如果这个区间距离超过了 mid，就需要加路标
        if dist > mid:
            # 核心公式：(dist - 1) // mid
            # 例子：dist=6, mid=3 -> (5)//3 = 1 个 (插在3的位置)
            # 例子：dist=7, mid=3 -> (6)//3 = 2 个 (插在3, 6的位置，剩1)
            count += (dist - 1) // mid
            
            # 剪枝：如果已经超过 K 个，直接 False，不用算后面了
            if count > K:
                return False
                
    return count <= K

# 3. 二分答案
l, r = 1, L # 距离最小是1，最大是全长
while l < r:
    # 模版2：找左边界（最小化最大值） -> mid 不加 1
    mid = (l + r) // 2
    
    if check(mid):
        r = mid     # mid 可行，尝试更小的距离
    else:
        l = mid + 1 # mid 不可行（需要太多路标），必须增大距离

print(l)
```
