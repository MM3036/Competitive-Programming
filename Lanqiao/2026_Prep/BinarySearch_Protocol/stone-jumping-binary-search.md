# 算法学习笔记：二分答案与贪心判定——《跳石头》

## 1. 题目描述

**题目名称**：跳石头 (NOIP 2015 / 蓝桥杯真题)

**背景**：
一项比赛在一条笔直的河道中进行，起点到终点的距离为 $L$。在起点和终点之间，分布着 $N$ 块岩石。选手从起点出发，每一步跳向相邻的岩石，直至到达终点。

**任务**：
为了提高难度，组委会计划移走一些岩石，使得选手们在比赛过程中的**最短跳跃距离尽可能长**。
由于预算限制，至多从起点和终点之间移走 $M$ 块岩石（起点和终点不能移走）。
需计算：在移走不超过 $M$ 块岩石的情况下，最短跳跃距离的最大值是多少？

**输入格式**：
*   第一行包含三个整数 $L, N, M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及至多移走的岩石数。
*   接下来 $N$ 行，每行一个整数 $D_i$，表示第 $i$ 块岩石与起点的距离。岩石按距离从小到大给出。

**输出格式**：
*   输出一个整数，表示最短跳跃距离的最大值。

**数据范围**：
*   $0 \le M \le N \le 50,000$
*   $1 \le L \le 1,000,000,000$

---

## 2. 核心考点与思想

> **核心金句**：
> 二分答案最妙的地方就在这里：它把一个复杂的“最优化问题”（寻找最优解），降维成了一个简单的“判定性问题”（判断行不行）。

**考点解析**：

1.  **数据特征暗示**：
    *   $L$ 的范围高达 $10^9$，直接排除了线性枚举的可能性。
    *   $N$ 为 $5 \times 10^4$，通常要求 $O(N \log N)$ 或 $O(N \log L)$ 的复杂度。
    *   这正是**“二分答案”**的典型应用场景。

2.  **单调性验证**：
    *   若一个较短的跳跃距离 $X$ 可以满足条件（移走岩石数 $\le M$），那么比 $X$ 更短的距离一定也能满足（不需要移走更多岩石）。
    *   反之，若 $X$ 不满足，比 $X$ 更长的距离更不可能满足。
    *   这种答案的**单调性**是使用二分的理论基础。

---

## 3. 解题误区与复盘 (My Mistakes)

在解题过程中，容易出现以下思维误区和代码错误，需引以为戒：

1.  **静态统计误区 (Static Gap Fallacy)**
    *   ❌ **错误思路**：计算所有相邻岩石的间距，存入列表，然后贪心地移除最小的间距。
    *   🔍 **根本原因**：忽略了动态变化。移走一块岩石后，左右两边的间距会合并成一个新的、更大的间距。静态统计无法预测这些新产生的间距。
    *   ✅ **修正**：放弃静态预处理，转为**动态模拟 (Simulate)** 跳跃过程。

2.  **输入处理与类型错误**
    *   ❌ **错误**：使用 `map(str, ...)` 读取数据，导致后续比较（如 `step < mid`）时抛出类型错误。
    *   ✅ **修正**：算法题中涉及计算的输入必须第一时间转换为 `int`。

3.  **边界条件遗漏 (Fencepost Error)**
    *   ❌ **错误**：在 `check` 函数循环结束后，忘记检查最后一块保留的岩石到终点 $L$ 的距离。
    *   ⚠️ **后果**：如果最后一步跨度小于目标值，该方案本应判定为非法，但因遗漏检查而被误判为合法。
    *   ✅ **修正**：循环外必须单独判断 `L - current_pos < mid` 的情况。

4.  **二分模版细节**
    *   ❌ **错误**：在寻找“最大值”（右边界）时，使用了 `mid = (l + r) // 2`。
    *   ⚠️ **后果**：当 $l$ 和 $r$ 相邻时（如 $l=2, r=3$），$mid$ 向下取整为 2。若 `check(2)` 成功，$l$ 更新为 2，导致死循环。
    *   ✅ **修正**：查找右边界时，计算 $mid$ 必须向上取整，即 `mid = (l + r + 1) // 2`。

---

## 4. 正解逻辑构建 (Algorithm Design)

### Step 1: 二分搜索框架
*   在区间 $[1, L]$ 内二分枚举答案 $mid$（假设的最短跳跃距离）。
*   使用“找最大值”模版：
    *   若 `check(mid)` 返回 `True`，说明 $mid$ 可行，尝试更大的距离 ($l = mid$)。
    *   否则缩小范围 ($r = mid - 1$)。

### Step 2: 贪心判定函数 `check(d)`
*   **模拟裁判视角**：假设要求每一步跳跃距离至少为 $d$，验证是否能在移除不超过 $M$ 块岩石的前提下做到。
*   **模拟过程**：
    1.  从起点出发，记录当前所在位置 `current_pos`（初始为0）。
    2.  遍历每一块岩石：
        *   若 `岩石位置 - current_pos < d`：说明跳不过去，**必须移走**该岩石。移走计数器 $+1$，`current_pos` 保持不变（因为石头没了，还在原位）。
        *   若 `岩石位置 - current_pos >= d`：说明可以跳过去，保留该岩石。更新 `current_pos` 为该岩石位置。
    3.  **终点检查**：遍历结束后，检查 `L - current_pos < d`。若不足，说明最后一步跳不到终点，需再移除一块（逻辑上判定不满足，计入移除数）。
    4.  **返回结果**：判断 `总移除数 <= M`。

---

## 5. 正确代码实现 (Python)

```python
import sys

# 增加递归深度与读取速度（针对大规模数据）
input = sys.stdin.read

def solve():
    # 1. 数据读取与处理
    data = input().split()
    iterator = iter(data)
    
    try:
        L = int(next(iterator))
        N = int(next(iterator))
        M = int(next(iterator))
        
        rocks = []
        for _ in range(N):
            rocks.append(int(next(iterator)))
    except StopIteration:
        return

    # 2. 定义判定函数 check(mid)
    # mid 代表我们假设的“最短跳跃距离”
    def check(d):
        removed_count = 0
        current_pos = 0  # 站在起点
        
        for rock_pos in rocks:
            # 计算当前跳跃距离
            gap = rock_pos - current_pos
            
            if gap < d:
                # 距离小于目标值，说明这块石头必须移走（为了凑出更大的间距）
                removed_count += 1
            else:
                # 距离足够，跳过去
                current_pos = rock_pos
        
        # ⚠️ 关键点：检查最后一块石头到终点的距离
        if L - current_pos < d:
            removed_count += 1
            
        # 如果移走的石头数量 <= M，说明这个距离 d 是可行的
        return removed_count <= M

    # 3. 二分答案
    # 答案范围在 [1, L] 之间
    left, right = 1, L
    
    while left < right:
        # ⚠️ 注意：寻找右边界（最大值）时，mid 需要向上取整，防止死循环
        mid = (left + right + 1) // 2
        
        if check(mid):
            # 如果 mid 可行，说明答案可能是 mid 或更大
            left = mid
        else:
            # 如果 mid 不可行，说明 mid 太大了，答案在左边
            right = mid - 1
            
    print(left)

if __name__ == "__main__":
    solve()
```
