# 矩形的共鸣 (Resonance of Rectangles)

## 题目描述
你需要构造两个矩形，矩形 A 和矩形 B。

### 变量定义
*   矩形的边长 $W_A, H_A, W_B, H_B$ 均为正整数。
*   **限制**：两个矩形的面积之积不得超过 $L$。即：$(W_A \cdot H_A) \cdot (W_B \cdot H_B) \le L$。
*   **能量定义**：矩形的“能量”为它的半周长（即 $W + H$）。

### 目标
计算在所有满足条件的方案中，（矩形 A 的能量 $\times$ 矩形 B 的能量）的总和。

### 数据范围与要求
*   $1 \le L \le 10^5$。
*   输出答案对 $10^9 + 7$ 取模。

---

## 核心解法：三步解耦法

### 第一步：数学模型（切入点）
**降维打击**：题目限制的是面积乘积，而非具体边长。因此，我们先枚举面积，再处理形状。

1.  **定义函数**：设 $u$ 为矩形 A 的面积，$v$ 为矩形 B 的面积。
2.  **能量聚合**：定义 $E[x]$ 为面积为 $x$ 的所有可能矩形的能量之和。
3.  **推导公式**：利用乘法分配律，确定面积 $u$ 和 $v$ 后，总贡献为 $E[u] \times E[v]$。
    $$Ans = \sum_{u=1}^{L} \left( E[u] \times \sum_{v=1}^{\lfloor L/u \rfloor} E[v] \right)$$

### 第二步：算法工程（优化瓶颈）
1.  **计算 $E$ 数组（调和级数筛法）**：
    *   **问题**：逐个分解质因数太慢。
    *   **优化**：枚举因子 $i$ 和倍数 $j$，反向填充。即 `E[j] += (i + j//i)`。
    *   **复杂度**：$O(L \log L)$。
2.  **计算求和 $\sum$（前缀和）**：
    *   **问题**：内层循环反复求和太慢。
    *   **优化**：预处理前缀和数组 $S[x] = \sum_{k=1}^{x} E[k]$。
    *   **效果**：内层求和变为 $O(1)$ 查表。
    *   **总复杂度**：$O(L)$（预处理后）。

### 第三步：代码实现（细节处理）
*   **数据类型**：全程注意数值可能过大，使用 `long long`（Python 自动处理大数），步步取模。
*   **下标映射**：数组大小开到 $L+1$，下标直接对应面积，符合直觉。

---

## Python 代码实现

```python
import sys

# 增加递归深度（本题非必需，但作为算法题习惯）
sys.setrecursionlimit(2000)

def solve():
    # ------------------------------------------------
    # 1. 输入处理
    # ------------------------------------------------
    try:
        input_data = sys.stdin.read().split()
        if not input_data:
            return
        L = int(input_data[0])
    except ValueError:
        return

    MOD = 10**9 + 7

    # ------------------------------------------------
    # 2. 预处理 E 数组 (筛法思想 - O(L log L))
    #    E[j] = 面积为 j 的所有矩形半周长之和
    # ------------------------------------------------
    E = [0] * (L + 1)
    
    # i 代表矩形的一条边长
    for i in range(1, L + 1):
        # j 代表矩形的面积
        # 逻辑：既然 i 是边长，j 是面积，那么 j 必须是 i 的倍数
        # start=i, step=i 保证了 j 永远能被 i 整除
        for j in range(i, L + 1, i):
            # 另一条边是 j // i
            # 能量贡献 = 边1 + 边2
            E[j] += (i + j // i)

    # ------------------------------------------------
    # 3. 预处理 S 数组 (前缀和思想 - O(L))
    #    S[x] = E[1] + ... + E[x]
    # ------------------------------------------------
    S = [0] * (L + 1)
    for i in range(1, L + 1):
        S[i] = (S[i-1] + E[i]) % MOD

    # ------------------------------------------------
    # 4. 主循环计算答案 (公式推导结果 - O(L))
    #    Ans = sum( E[u] * S[L // u] )
    # ------------------------------------------------
    ans = 0
    
    # 枚举矩形 A 的面积 u
    for u in range(1, L + 1):
        # 计算矩形 B 的最大允许面积
        max_v = L // u
        
        if max_v == 0:
            continue
            
        # E[u] 是 A 的贡献
        # S[max_v] 是 B 在面积 1 到 max_v 范围内所有情况的总贡献
        term = (E[u] * S[max_v]) % MOD
        ans = (ans + term) % MOD

    print(ans)

if __name__ == '__main__':
    solve()
```

---

## 关键点速查表（Cheat Sheet）

| 步骤 | 关键问题 | 解决方案 | 复杂度 |
| :--- | :--- | :--- | :--- |
| **推导** | 四个变量怎么消？ | 按面积 $u, v$ 分类，利用乘法分配律。 | N/A |
| **E数组** | 因子和怎么算快？ | 调和级数筛法 (`for i... for j+=i`)。 | $O(L \log L)$ |
| **求和** | 区间求和怎么快？ | 前缀和 (`S[i] = S[i-1] + E[i]`)。 | $O(L)$ |
| **边界** | 除法怎么处理？ | 向下取整 (`//`)，即 $B$ 的最大面积。 | $O(1)$ |


---

# 矩形组合能量统计：从数论困境到线性突破

针对约束条件 $(W_A H_A)(W_B H_B) \le L$ 下，计算 $\sum (W_A+H_A)(W_B+H_B)$ 的算法优化全过程。

## 1. 核心思维重构（Cognitive Roadmap）

本部分记录了从直觉困境到逻辑突破的建模过程。

### 突破点一：建立等价类（Handling Irregularity via Abstraction）
*   **困境**：试图直接枚举 $W+H$ 时，受阻于自然数因子分布的不规则性（质数因子少，合数因子多），导致逻辑无法统一。
*   **模型构建**：“找整体代替，而非全部展开”。不再纠结于具体的 $(W, H)$ 组合，而是建立等价类。
*   **定义**：$E[i]$ 为面积为 $i$ 的所有可能矩形的边长之和：
    $$E[i] = \sum_{w \cdot h = i} (w + h)$$
*   **意义**：将复杂的数论结构封装在 $E[i]$ 内部，外部计算转化为对线性索引 $i$ 的操作，实现了从“微观离散”到“宏观抽象”的转换。

### 突破点二：变量解耦与线性化（Fix-and-Iterate Strategy）
*   **困境**：面对双变量约束 $u \cdot v \le L$，变量间存在强耦合，无法独立遍历。
*   **模型构建**：“遍历关联变量，必须定一移一”。
*   **定一**：固定变量 $u$（即矩形 A 的面积），作为主循环基准。
*   **移一**：在 $u$ 确定的前提下，变量 $v$（即矩形 B 的面积）的上限坍缩为线性边界 $\lfloor L/u \rfloor$。
*   **意义**：将二维双曲线区域内的无序搜索，拆解为 $L$ 次有序的一维区间扫描，为使用**前缀和优化**创造了条件。

---

## 2. 题目描述与形式化

**目标**：计算所有满足条件的矩形对的维度和之积。
$$\text{Maximize: } \sum (W_A+H_A)(W_B+H_B)$$

**约束条件**：
$$(W_A \cdot H_A) \cdot (W_B \cdot H_B) \le L$$

**公式转换**：
令 $u = \text{Area}_A, v = \text{Area}_B$，则原式可简化为：
$$\text{Ans} = \sum_{u \cdot v \le L} (E[u] \times E[v])$$

---

## 3. 核心算法流程（三步解耦法）

### Step 1: 预处理 E 数组 (调和级数筛法)
利用突破点一的“整体代替”思想。
*   **逻辑**：不枚举面积找因子，而是枚举因子 $i$ 找其能构成的面积 $j$。
*   **操作**：
    ```python
    for i in 1..L:
        for j in i..L step i:
            E[j] += (i + j // i)
    ```
*   **复杂度**：$O(L \log L)$

### Step 2: 预处理 S 数组 (前缀和)
为突破点二的“区间扫描”做准备。
*   **逻辑**：将连续的 $E$ 值累加，实现 $O(1)$ 查询。
*   **操作**：
    $$S[i] = \sum_{k=1}^{i} E[k]$$
    ```python
    for i in 1..L:
        S[i] = S[i-1] + E[i]
    ```

### Step 3: 主逻辑计算 (定一移一)
利用突破点二的“线性化”思想。
*   **逻辑**：枚举 $u$，计算 $v$ 的最大范围 $\lfloor L/u \rfloor$，查表求和。
*   **核心公式**：
    $$\text{Ans} = \sum_{u=1}^{L} \left( E[u] \times S\left[\left\lfloor \frac{L}{u} \right\rfloor\right] \right)$$
*   **复杂度**：$O(L)$

---

## 4. 复杂度总结

| 阶段 | 算法 | 时间复杂度 | 说明 |
| :--- | :--- | :--- | :--- |
| **预处理 E** | 调和级数筛法 | $O(L \log L)$ | 类似于素数筛的效率 |
| **预处理 S** | 前缀和累加 | $O(L)$ | 线性扫描 |
| **主逻辑计算**| 线性查表 | $O(L)$ | 双变量解耦后的效率 |
| **总计** | | **$O(L \log L)$** | 远优于朴素暴力枚举 |

---

