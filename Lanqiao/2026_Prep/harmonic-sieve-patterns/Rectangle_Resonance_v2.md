# 矩形的共鸣 (Resonance of Rectangles)

## 题目描述
你需要构造两个矩形，矩形 A 和矩形 B。

### 变量定义
*   矩形的边长 $W_A, H_A, W_B, H_B$ 均为正整数。
*   **限制**：两个矩形的面积之积不得超过 $L$。即：$(W_A \cdot H_A) \cdot (W_B \cdot H_B) \le L$。
*   **能量定义**：矩形的“能量”为它的半周长（即 $W + H$）。

### 目标
计算在所有满足条件的方案中，（矩形 A 的能量 $\times$ 矩形 B 的能量）的总和。

### 数据范围与要求
*   $1 \le L \le 10^5$。
*   输出答案对 $10^9 + 7$ 取模。

---

## 核心解法：三步解耦法

### 第一步：数学模型（切入点）
**降维打击**：题目限制的是面积乘积，而非具体边长。因此，我们先枚举面积，再处理形状。

1.  **定义函数**：设 $u$ 为矩形 A 的面积，$v$ 为矩形 B 的面积。
2.  **能量聚合**：定义 $E[x]$ 为面积为 $x$ 的所有可能矩形的能量之和。
3.  **推导公式**：利用乘法分配律，确定面积 $u$ 和 $v$ 后，总贡献为 $E[u] \times E[v]$。
    $$Ans = \sum_{u=1}^{L} \left( E[u] \times \sum_{v=1}^{\lfloor L/u \rfloor} E[v] \right)$$

### 第二步：算法工程（优化瓶颈）
1.  **计算 $E$ 数组（调和级数筛法）**：
    *   **问题**：逐个分解质因数太慢。
    *   **优化**：枚举因子 $i$ 和倍数 $j$，反向填充。即 `E[j] += (i + j//i)`。
    *   **复杂度**：$O(L \log L)$。
2.  **计算求和 $\sum$（前缀和）**：
    *   **问题**：内层循环反复求和太慢。
    *   **优化**：预处理前缀和数组 $S[x] = \sum_{k=1}^{x} E[k]$。
    *   **效果**：内层求和变为 $O(1)$ 查表。
    *   **总复杂度**：$O(L)$（预处理后）。

### 第三步：代码实现（细节处理）
*   **数据类型**：全程注意数值可能过大，使用 `long long`（Python 自动处理大数），步步取模。
*   **下标映射**：数组大小开到 $L+1$，下标直接对应面积，符合直觉。

---

## Python 代码实现

```python
import sys

# 增加递归深度（本题非必需，但作为算法题习惯）
sys.setrecursionlimit(2000)

def solve():
    # ------------------------------------------------
    # 1. 输入处理
    # ------------------------------------------------
    try:
        input_data = sys.stdin.read().split()
        if not input_data:
            return
        L = int(input_data[0])
    except ValueError:
        return

    MOD = 10**9 + 7

    # ------------------------------------------------
    # 2. 预处理 E 数组 (筛法思想 - O(L log L))
    #    E[j] = 面积为 j 的所有矩形半周长之和
    # ------------------------------------------------
    E = [0] * (L + 1)
    
    # i 代表矩形的一条边长
    for i in range(1, L + 1):
        # j 代表矩形的面积
        # 逻辑：既然 i 是边长，j 是面积，那么 j 必须是 i 的倍数
        # start=i, step=i 保证了 j 永远能被 i 整除
        for j in range(i, L + 1, i):
            # 另一条边是 j // i
            # 能量贡献 = 边1 + 边2
            E[j] += (i + j // i)

    # ------------------------------------------------
    # 3. 预处理 S 数组 (前缀和思想 - O(L))
    #    S[x] = E[1] + ... + E[x]
    # ------------------------------------------------
    S = [0] * (L + 1)
    for i in range(1, L + 1):
        S[i] = (S[i-1] + E[i]) % MOD

    # ------------------------------------------------
    # 4. 主循环计算答案 (公式推导结果 - O(L))
    #    Ans = sum( E[u] * S[L // u] )
    # ------------------------------------------------
    ans = 0
    
    # 枚举矩形 A 的面积 u
    for u in range(1, L + 1):
        # 计算矩形 B 的最大允许面积
        max_v = L // u
        
        if max_v == 0:
            continue
            
        # E[u] 是 A 的贡献
        # S[max_v] 是 B 在面积 1 到 max_v 范围内所有情况的总贡献
        term = (E[u] * S[max_v]) % MOD
        ans = (ans + term) % MOD

    print(ans)

if __name__ == '__main__':
    solve()
```

---

## 关键点速查表（Cheat Sheet）

| 步骤 | 关键问题 | 解决方案 | 复杂度 |
| :--- | :--- | :--- | :--- |
| **推导** | 四个变量怎么消？ | 按面积 $u, v$ 分类，利用乘法分配律。 | N/A |
| **E数组** | 因子和怎么算快？ | 调和级数筛法 (`for i... for j+=i`)。 | $O(L \log L)$ |
| **求和** | 区间求和怎么快？ | 前缀和 (`S[i] = S[i-1] + E[i]`)。 | $O(L)$ |
| **边界** | 除法怎么处理？ | 向下取整 (`//`)，即 $B$ 的最大面积。 | $O(1)$ |
