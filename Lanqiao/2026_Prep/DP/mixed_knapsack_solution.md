# 算法学习笔记：混合背包问题

## 一、 核心知识点

1.  **01背包问题**
    *   每种物品仅有一件，可以选择放或不放。
    *   **核心实现**：一维状态数组下的**逆序遍历**容量，以确保每件物品最多只被计算一次。

2.  **完全背包问题**
    *   每种物品有无限件。
    *   **核心实现**：一维状态数组下的**正序遍历**容量，使得物品的状态可以基于当前阶段已放入同一物品的状态进行叠加。

3.  **多重背包问题（二进制拆分优化）**
    *   每种物品有有限的 $s$ 件。
    *   **核心实现**：通过将其拆分为数量为 $1, 2, 4, \dots, 2^k, s - 2^{k+1} + 1$ 的若干个新物品，转化为 01 背包问题求解。
    *   该方法将时间复杂度从 $O(N V s)$ 优化至 $O(V \sum \log s_i)$。

4.  **空间压缩**
    *   利用滚动数组思想，将二维状态 $dp[i][j]$ 压缩为一维 $dp[j]$，空间复杂度降低至 $O(V)$。

---

## 二、 题目描述

### 题目名称：小明的终极装备库（混合背包收官战）

**问题背景：**
给定一个总容量为 $V$ 的背包和 $N$ 种物品（装备）。第 $i$ 种物品具有三个属性：体积 $w_i$、价值 $v_i$ 以及获取标识符 $s_i$。

**获取标识符定义：**
*   当 $s_i = -1$ 时，该物品为**唯一物品**（01背包，最多选取 1 次）。
*   当 $s_i = 0$ 时，该物品为**无限物品**（完全背包，选取次数不受数量限制，仅受背包容量限制）。
*   当 $s_i > 0$ 时，该物品为**有限物品**（多重背包，最多只能选取 $s_i$ 次）。

**求解目标：**
在所选物品总体积不超过背包总容量 $V$ 的前提下，计算并输出能够获得的最大总价值。

**输入格式：**
*   第一行包含两个整数 $N$ 和 $V$。
*   接下来 $N$ 行，每行包含三个整数 $w_i$, $v_i$, $s_i$。

**输出格式：**
*   输出一个整数，表示最大价值总和。

---

## 三、 标准正确答案

以下代码采用了 Python 原生迭代器以实现最优的 I/O 性能，并结合二进制拆分与一维状态数组完成了混合背包的统一降维转移。

```python
import sys

def solve():
    # 使用 sys.stdin.read().split() 结合 map 构建迭代器，极大优化读入速度
    data = map(int, sys.stdin.read().split())
    
    try:
        N = next(data) # 物品种类数
        V = next(data) # 背包总容量
    except StopIteration:
        return

    # 初始化 DP 数组，空间复杂度 O(V)
    dp = [0] * (V + 1)
    
    for _ in range(N):
        w = next(data) # 体积
        v = next(data) # 价值
        s = next(data) # 标识符
        
        if s == -1:
            # 01背包：逆序遍历
            for j in range(V, w - 1, -1):
                if dp[j] < dp[j - w] + v:
                    dp[j] = dp[j - w] + v
                    
        elif s == 0:
            # 完全背包：正序遍历
            for j in range(w, V + 1):
                if dp[j] < dp[j - w] + v:
                    dp[j] = dp[j - w] + v
                    
        else:
            # 多重背包：二进制拆分
            k = 1
            while s >= k:
                w_t = k * w
                v_t = k * v
                # 拆分后按 01背包 处理（逆序遍历）
                for j in range(V, w_t - 1, -1):
                    if dp[j] < dp[j - w_t] + v_t:
                        dp[j] = dp[j - w_t] + v_t
                s -= k
                k *= 2
                
            # 处理拆分后剩余的物品
            if s != 0:
                w_t = s * w
                v_t = s * v
                for j in range(V, w_t - 1, -1):
                    if dp[j] < dp[j - w_t] + v_t:
                        dp[j] = dp[j - w_t] + v_t

    # 输出背包容量为 V 时的最大价值
    print(dp[V])

if __name__ == '__main__':
    solve()
```
