# 算法笔记：完全背包问题核心推演与蓝桥杯实战

## 一、 核心知识点

*   **完全背包模型定义**
    给定 $N$ 种物品和一个容量为 $V$ 的背包，**每种物品都有无限件可用**。第 $i$ 种物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

*   **状态定义**
    一维数组 $dp[j]$ 表示背包容量上限为 $j$ 时，能获得的最大价值。

*   **状态转移方程**
    $$dp[j] = \max(dp[j], dp[j - v_i] + w_i)$$

*   **核心差异（对比 0-1 背包）**
    *   **0-1 背包**：内层循环容量 $j$ 必须**倒序**遍历，确保物品只被选取一次（状态依赖于上一层）。
    *   **完全背包**：内层循环容量 $j$ 必须**正序**遍历，使得状态可以依赖于当前层已更新的数据，从而实现同一物品的无限次选取。

## 二、 实战题目：小明的灵石收集（蓝桥杯模拟）

### 【题目描述】
小明在探索秘境时发现了一个古老的灵石阵。阵法中散落着 $N$ 种不同类型的灵石，每种灵石的储量均视为无限。小明随身携带了一个容量为 $V$ 的高级储物袋。已知第 $i$ 种灵石的体积为 $v_i$，蕴含的灵力值为 $w_i$。请计算小明应该如何挑选灵石装入储物袋，才能使得带出的灵石总灵力值最大。（注意：储物袋无需装满，每种灵石可取任意多个）。

### 【输入格式】
第一行包含两个正整数 $V$ 和 $N$，分别代表储物袋的总容量和灵石的种类数，中间用一个空格隔开。
接下来 $N$ 行，每行包含两个正整数 $v_i$ 和 $w_i$，分别代表第 $i$ 种灵石的体积和蕴含的灵力值。

### 【输出格式】
输出一行，包含一个整数，表示小明能获得的最大总灵力值。

### 【评测用例规模与约定】
*   对于 30% 的数据，$1 \le N \le 10$，$1 \le V \le 100$。
*   对于 100% 的数据，$1 \le N \le 1000$，$1 \le V \le 10000$，$1 \le v_i, w_i \le 10000$。

### 【样例输入】
```text
10 2
4 7
3 5
```

### 【样例输出】
```text
17
```

## 三、 底层逻辑推演：四个过程与四个顿悟

从零构建动态规划思维，需经历以下四个核心认知阶段：

### 过程一：局部贪心策略的失效
*   **推演**：优先选择单位体积价值（性价比）最高的物品。
*   **顿悟：物品不可分割性导致空间浪费。**
    贪心算法仅关注单体收益，忽略了剩余空间的利用率。若高性价比物品导致剩余空间无法装入任何其他物品，其全局总价值往往劣于组合利用空间的次优解方案。因此，必须将“选取后剩余空间的完美利用”纳入决策考量。

### 过程二：逆向思维与最优子结构
*   **推演**：放弃从空背包正向尝试，转而假设已知全局最大容量 $V$ 的完美方案，利用反证法倒推其构成。
*   **顿悟：宏观最优解必然由微观最优解构成（最优子结构）。**
    若容量为 $V$ 的最优方案中包含了物品 $i$（体积为 $v_i$），剥离该物品后，剩余的物品组合必须是容量为 $V - v_i$ 时的最优方案。否则，用更优的 $V - v_i$ 方案替换当前组合，即可得出一个比“全局最优”更大的价值，产生逻辑矛盾。

### 过程三：状态的穷举与依赖
*   **推演**：由于事前无法预判全局最优解究竟包含哪些物品，也就无法预知需要依赖哪一个特定的子状态（剩余容量）。
*   **顿悟：递增求解是解决状态依赖的唯一途径。**
    为了确保求解容量 $V$ 时，所需的任意前置最优子状态（$V-v_1, V-v_2...$）均已存在，算法必须采用自底向上的动态规划策略，从容量 0 开始，系统性地计算并记录每一个递增容量的最优解。

### 过程四：空间降维与正序遍历的数学巧合
*   **推演**：在递增计算小体积状态时，分析一维数组 $dp[x]$ 的实际意义与更新方向。
*   **顿悟（两层核心认知）：**
    1.  **同一物品无限次选取的本质**：当采用**正序遍历**容量 $j$ 时，计算 $dp[j]$ 所依赖的 $dp[j - v_i]$ 已经是当前阶段更新过的数据。这意味 $dp[j - v_i]$ 中可能已经包含了物品 $i$，在此基础上加上 $w_i$，在数学上完美等价于对物品 $i$ 进行了第二次、第三次……无限次选取。
    2.  **状态的向下兼容性**：$dp[x]$ 的严谨定义为“容量上限为 $x$ 时的最大价值”，而非“精确填满 $x$”。由于体积和价值均为非负数，数组天然具有非递减的单调性。因此，状态转移 $dp[j - v_i]$ 内部已自动囊括了“不完全填满该剩余空间”的所有更优方案，无需额外去比对更小体积的状态。

## 四、 正确答案

```python
import sys
data = map(int, sys.stdin.read().split())
V = next(data)
N = next(data)
dp = [0] * (V + 1)
#一切的起点在于一场逆向思维的思维实验，完美的大背包一定由完美的小背包加相应物品，而小背包由小小背包组成，以此类推
#为什么只需要两部分但是却算了所有体积的背包？
#因为小小背包和小小小背包，小小小小背包不是凭空出现，当数量很大时这个数字很庞大，精准打击的成本远高于地毯式轰炸属于费力不讨好
for i in range(1, N + 1):
    v = next(data)
    w = next(data)
    for j in range(v, V + 1):
#dp[]内部存的都是最优解，所以dp[j - v] + w就是找腾出要装入的这个物品的体积v，看看剩下空间的最优解加上这件物品的价值和不加这件物品那个更好
        dp[j] = max(dp[j], dp[j - v] + w)
print(dp[V])
```
