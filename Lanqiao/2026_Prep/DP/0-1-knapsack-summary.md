# 0-1背包问题总结

## 题目描述

小明有一个容量为 $V$ 的背包。商场一共有 $N$ 件物品，第 $i$ 件物品的体积为 $w$，价值为 $v$。在背包容量允许的范围内，求能装入背包的物品的最大总价值。每件物品只能选择装入一次或不装入。

**输入格式：**
第一行包含两个正整数 $N$ 和 $V$，分别表示物品件数和背包容量。
接下来 $N$ 行，每行包含两个正整数 $w$ 和 $v$，分别表示第 $i$ 件物品的体积和价值。

**数据范围：**
$N \le 1000$
$V \le 20000$

## 知识点核心

*   **动态规划自底向上递推**
    通过记录重叠子问题的最优解，将所有容量的可能性全部算出，避免递归造成的指数级重复计算。

*   **一维空间优化**
    利用滚动数组的思想，将空间复杂度进行极致压缩，将二维 `dp[i][j]` 优化为一维 `dp[j]`。

*   **倒序遍历机制**
    内层循环在遍历容量时**必须倒序进行**（从 $V$ 到 $w_i$）。这是为了保证在更新当前容量时，所引用的减去体积后的容量状态 `dp[j - w]`，绝对是没有被当前物品污染过的、上一轮的历史干净状态，从而严格保证 0-1 背包中每件物品只被选取一次的特性。

## 失误复盘

*   **数组越界错误**
    在初始化 DP 数组时，长度设定错误。因为要涵盖从容量 0 到满容量 $V$ 的所有情况，数组长度必须声明为 `V + 1`，否则在处理满容量状态时会发生索引越界。

*   **状态转移逻辑偏差**
    在执行容量价值比较时，未正确调用自身历史状态。状态转移方程应当是将自身的原有历史价值与腾出空间装入新物品后的价值进行比较（`max(dp[j], dp[j-w] + v)`），而不是与容量减 1 的相邻状态（`dp[j-1]`）进行比较。

## 正确答案

```python
import sys

# 读取全部输入数据
data = map(int, sys.stdin.read().split())
N = next(data)
V = next(data)

# 修正 1：数组长度开到 V + 1
dp = [0] * (V + 1)

for i in range(N):
    w = next(data)
    v = next(data)
    
    # 完美！精准掌握了从大到小的倒序遍历
    for j in range(V, w - 1, -1):
        # 修正 2：和 dp[j] 自身进行比较
        dp[j] = max(dp[j], dp[j - w] + v)

# 打印最终格子上的最高价值
print(dp[V])
```

***

