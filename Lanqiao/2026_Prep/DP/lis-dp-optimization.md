# 算法笔记：最长递增子序列 (LIS) 基础与优化

## 一、 题目描述

### 【问题描述】
小明在探索一个神秘的遗迹时，发现了一个由发光法力石组成的阵法。阵法由一排法力石构成，每块石头上都刻着一个能量值。为了破解阵法，小明需要从左到右依次激活部分法力石。

遗迹的规则要求：为了确保阵法能量不冲突，小明每次激活的法力石的能量值，**必须严格大于上一次激活的法力石的能量值**。

计算小明最多能激活多少块法力石。

### 【输入格式】
第一行包含一个整数 $N$（$1 \le N \le 1000$），表示法力石的数量。
第二行包含 $N$ 个整数，表示从左到右每块法力石的能量值，数字之间用空格隔开（能量值在 $1$ 到 $10000$ 之间）。

### 【输出格式】
输出一个整数，表示小明最多能激活的法力石数量。

### 【样例输入】
```plaintext
7
1 7 3 5 9 4 8
```

### 【样例输出】
```plaintext
4
```
*(提示：样例中最长的递增激活顺序可以是 1 3 5 9 或 1 3 5 8)*

---

## 二、 知识点总结

*   **状态定义**：
    $dp[i]$ 表示必须以 $num[i]$ 结尾的最长递增子序列的长度。
*   **状态转移方程**：
    $dp[i] = \max(dp[i], dp[j] + 1)$
    条件为 $0 \le j < i$ 且 $num[j] < num[i]$。
*   **初始化**：
    每个元素自身可构成长度为 1 的子序列，故 $dp$ 数组初始化为全 1。
*   **时间复杂度**：
    $O(N^2)$。
*   **最终结果**：
    $\max(dp)$，即所有以各个元素结尾的最长子序列长度中的最大值。

---

## 三、 个人失误分析

1.  **逻辑错误 (Runtime Error)**：
    在状态转移时，尝试每次在循环内初始化空列表 `max_re = []`。若输入严格递减序列（如 `5 4 3 2 1`），因找不到比当前元素更小的值，列表持续为空。此时对空列表调用 `max()` 函数会导致程序抛出 `ValueError` 崩溃。

2.  **性能缺陷**：
    在两层嵌套循环内部频繁开辟内存空间（创建空列表）并执行 `append` 操作，极大增加了底层内存分配与垃圾回收的开销，严重降低程序运行效率。

---

## 四、 正确代码对比

### 解法一：标准解法（使用内置 max 函数）

**描述**：
预先初始化 $dp$ 数组为全 1。外层循环遍历当前元素，内层循环遍历其前面的元素。满足严格递增条件时，利用 Python 内置的 `max()` 函数更新当前 $dp[i]$ 的值。此写法逻辑直观，但在 Python 中，内层循环频繁调用内置函数会产生额外的函数调用栈开销。

```python
import sys

# 读取输入
data = map(int, sys.stdin.read().split())
N = next(data)
num = [next(data) for _ in range(N)]

# 预先初始化 dp 数组
dp = [1] * N

# 状态转移
for i in range(1, N):
    for j in range(i):
        if num[j] < num[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 输出结果
print(max(dp))
```

### 解法二：极致优化解法（使用纯 if 替代 max 函数）

**描述**：
在外层循环提前提取当前值 `num_i` 并声明局部变量 `max_val = 1`。内层循环中，利用纯 `if` 条件判断替代 `max()` 函数进行大小比较与赋值。内层循环结束后，将最终的局部最大值赋给 $dp[i]$。此写法消除了函数调用栈开销、避免了不必要的列表内存开辟以及多余的数组下标访问，在竞赛环境下面对较大数据量时运行速度显著提升。

```python
import sys

# 读取输入
data = map(int, sys.stdin.read().split())
N = next(data)
num = [next(data) for _ in range(N)]

# 预先初始化 dp 数组
dp = [1] * N

# 状态转移优化
for i in range(1, N):
    num_i = num[i]
    max_val = 1  # 局部变量记录最大长度
    
    for j in range(i):
        if num[j] < num_i:
            temp = dp[j] + 1
            # 使用纯 if 替代 max() 函数
            if temp > max_val:
                max_val = temp
                
    dp[i] = max_val

# 输出结果
print(max(dp))
```
