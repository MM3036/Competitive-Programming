# 算法笔记：最长递增子序列 (LIS) 进阶优化与二分查找

## 一、 题目描述

### 【问题描述】
小明在探索一个神秘的遗迹时，发现了一个由发光法力石组成的阵法。阵法由一排法力石构成，每块石头上都刻着一个能量值。
为了破解阵法，小明需要从左到右依次激活部分法力石。遗迹的规则要求：为了确保阵法能量不冲突，小明每次激活的法力石的能量值，必须严格大于上一次激活的法力石的能量值。
请计算小明最多能激活多少块法力石。

### 【输入格式】
第一行包含一个整数 $N$ ($1 \le N \le 10^5$)，表示法力石的数量。
第二行包含 $N$ 个整数，表示从左到右每块法力石的能量值，数字之间用空格隔开（能量值在 1 到 $10^9$ 之间）。

### 【输出格式】
输出一个整数，表示小明最多能激活的法力石数量。

### 【样例输入】
```text
7
1 7 3 5 9 4 8
```

### 【样例输出】
```text
4
```

---

## 二、 知识点总结：O(NlogN) 贪心与动态规划结合

**算法核心哲学**：DP 根本不预测未来，它只绝对完美地总结过去。算法不关心当前的高潜力选择在未来是否必定有元素接盘，而是稳健地锁住已有的历史最高收益（最大长度），同时利用每一个新元素去极限刷新各个长度的“潜力底线”。

1.  **状态定义反转**：
    摒弃传统 $O(N^2)$ 中“以第 $i$ 个元素结尾的最长长度”的定义。引入“潜力数组”（设为 `dp`），定义 `dp[len]` 为：**长度为 `len+1` 的所有严格递增子序列中，末尾元素的最小值**。

2.  **状态的单调性**：
    由于序列是严格递增的，越长的子序列其末尾元素必然越大，因此 `dp` 数组天生保持严格单调递增。这为引入二分查找提供了理论基础。

3.  **状态转移本质（贪心策略）**：
    遍历原数组，设当前元素为 `x`。利用二分查找寻找插入位置，此过程本质上完成了一个极其优雅的动态规划状态转移方程：
    $$dp[len] = \min(dp[len], x)$$

    **方程解析**：
    *   **开疆扩土**：若 `x` 大于 `dp` 数组的最后一个元素，意味着找到了一个比以往所有记录都长的新序列，直接将 `x` 追加到末尾，最大长度加 1。
    *   **优胜劣汰（刷新潜力）**：若 `x` 小于或等于 `dp` 数组的最后一个元素，通过二分查找找到第一个大于等于 `x` 的位置 `len`。此时执行 `dp[len] = x`（即前文的 min 操作生效）。其物理意义是：在长度同为 `len+1` 的序列中，新元素 `x` 提供了更小的结尾门槛，无情替换掉原有的较大值，从而为后续元素的接入提供更广阔的空间。

4.  **时间复杂度**：
    外层循环遍历 $N$ 个元素，内层使用二分查找定位时间复杂度为 $O(\log N)$，总体时间复杂度为 $O(N \log N)$。

5.  **最终结果**：
    遍历结束后，`dp` 数组的有效长度即为原数组的最长递增子序列的长度。
    *注意：`dp` 数组内部存储的元素组合并非原数组的真实递增子序列。*

---

## 三、 bisect 库核心机制总结

`bisect` 是 Python 标准库中底层由 C 语言实现的高效二分查找模块，专用于在 **已排序（升序）** 的序列中查找插入位置或维持排序。

**前提条件**：目标数组必须具备单调递增或非严格递增性质。

1.  **核心函数 `bisect_left(a, x, lo, hi)`**：
    *   **功能**：在有序数组 `a` 中查找元素 `x` 的插入位置。若数组中已存在与 `x` 相同的元素，则返回的插入点在这些相同元素的 **最左侧**。
    *   **数学等价**：用于查找数组中 **第一个大于等于 `x`** 的元素的索引。在求解 **严格递增** 的 LIS 问题时，必须使用此函数进行替换定位。

2.  **核心函数 `bisect_right(a, x, lo, hi)`**：
    *   **功能**：与 `left` 类似，但若数组中已存在与 `x` 相同的元素，则返回的插入点在这些相同元素的 **最右侧**。
    *   **数学等价**：用于查找数组中 **第一个严格大于 `x`** 的元素的索引。在求解 **非严格递增（不下降）** 子序列问题时，使用此函数。

3.  **区间参数 `lo` 与 `hi`**：
    *   允许限制二分查找的作用域为 `a[lo:hi]`。在预先开辟固定大小内存（如 `dp = [0] * N`）以优化性能的场景中，传入实际有效元素数量 `size` 作为 `hi` 参数，可精准界定查找范围，避免对未初始化区域进行无效查找。

4.  **性能规避**：
    *   库中包含 `insort` 系列函数（查找并插入）。但在算法竞赛的循环体中应严格避免使用，因 Python 列表的底层数组插入操作会引发 $O(N)$ 的内存移动开销，导致整体时间复杂度退化。应使用 `bisect_left` 获取索引后直接进行 $O(1)$ 的赋值替换。

---

## 四、 个人失误分析（手写二分实现）

在尝试结合预开辟数组手动实现二分查找时，暴露了以下逻辑与工程实现上的缺陷：

1.  **循环次数与有效长度混淆**
    *   **失误表现**：在二分查找的右边界初始化中，错误地将当前遍历的元素索引 `i` 赋值给右边界 `right`。
    *   **本质原因**：未能区分“原数组已读取的元素个数”与“状态数组 `dp` 中实际记录的有效潜力值个数”。若 `dp` 数组有效长度短于 `i`，会导致二分查找进入未初始化的全 0 区域，引发逻辑错误。
    *   **修正方案**：必须引入独立的整型变量（如 `size`）严格维护当前 `dp` 数组的有效长度，并以此作为二分查找的右边界。

2.  **二分查找区间收缩逻辑错误**
    *   **失误表现**：采用右偏置中位数 `mid = (left + right) // 2 + 1`，并使用 `tar >= dp[mid]` 试图收缩左边界。
    *   **本质原因**：LIS 的贪心替换要求寻找“第一个大于等于”目标值的位置。错误的收缩条件和偏置会导致跳过正确位置或陷入死循环。
    *   **修正方案**：采用标准左偏置模板。当 `dp[mid] < tar` 时，说明目标位置必然在右侧，执行 `left = mid + 1`；否则，目标位置可能是当前 `mid` 或在左侧，执行 `right = mid`。

3.  **结果统计方式不严谨**
    *   **失误表现**：遍历结束后，试图通过倒序遍历索引并判定 `i != 0` 来输出结果。
    *   **本质原因**：混淆了数组下标与数组元素的值。且缺乏 `break` 中断逻辑，导致输出冗余。若输入数据本身包含 0，判定条件亦会失效。
    *   **修正方案**：利用维护有效长度的 `size` 变量。当二分查找定位到的替换位置 `left` 等于 `size` 时，触发 `size += 1` 的逻辑。遍历结束后，`size` 的值即为所求的最长递增子序列长度，无需额外扫描。

---

## 五、 正确解法 (Python)

```python
import sys
from bisect import bisect_left

def solve():
    # 一次性读取并分割所有输入，转化为整数迭代器
    data = map(int, sys.stdin.read().split())
    
    try:
        N = next(data)
    except StopIteration:
        return
        
    # 极致优化 1：预先开辟数组，避免动态扩容开销
    dp = [0] * N
    size = 0  
    
    # 极致优化 2：直接遍历剩下的迭代器，利用 C 级别循环速度
    for tar in data:
        # 极致优化 3：利用 C 底层实现的二分查找，指定 [0, size) 查找范围
        left = bisect_left(dp, tar, 0, size)
        
        # 贪心替换
        dp[left] = tar
        
        # 如果插在了末尾，说明潜力数组变长了
        if left == size:
            size += 1

    print(size)

if __name__ == '__main__':
    solve()
```
