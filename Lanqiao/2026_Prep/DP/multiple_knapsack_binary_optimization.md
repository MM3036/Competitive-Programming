# 动态规划：多重背包与二进制优化总结

## 题目：小明的奖品采购（多重背包演练）

### 【题目描述】
总预算为 $V$ 元。商店里有 $N$ 种奖品。对于第 $i$ 种奖品，它的单价是 $w[i]$ 元，能带来的“惊喜度”（价值）为 $v[i]$，这种奖品最多只能购买 $s[i]$ 个。
计算在不超过总预算的前提下，如何采购才能让奖品的总惊喜度达到最大。

### 【输入格式】
第一行包含两个整数 $N$ 和 $V$，分别表示奖品的种类数和总预算。
接下来 $N$ 行，每行包含三个整数 $w[i], v[i], s[i]$，分别表示第 $i$ 种奖品的单价、惊喜度和最大库存数量。

### 【数据范围】
*   $1 \le N \le 1000$
*   $1 \le V \le 20000$
*   $1 \le w[i], v[i], s[i] \le 2000$

---

## 核心知识点：二进制拆分优化

### 原理
多重背包的朴素解法是将第 $i$ 种物品看作 $s_i$ 个独立的物品进行 0/1 背包计算，时间复杂度为 $O(V \times \sum s_i)$。在面对大数据量时（Python 对循环效率敏感），朴素解法极易导致超时（TLE）。

**二进制拆分**利用二进制数的组合性质，将数量为 $S$ 的同种物品，打包成数量为 $2^0, 2^1, 2^2, \dots, 2^k$ 以及一个余数 $R$ 的新物品。
例如：13 个物品可以拆分为 1, 2, 4, 6 (余数)。
*   $1+2+4+6 = 13$
*   任意 $1 \le k \le 13$ 的数字均可由这四个数组合而成。

此方法将时间复杂度从 $O(V \times \sum s_i)$ 降至 $O(V \times \sum \log s_i)$，大幅提升运行效率。

---

## 常见失误分析（变量污染）

在实现二进制拆分并计算新包裹的体积（重量）和价值时，若直接在原始变量上进行累乘赋值，会导致后续循环中使用的基准值被破坏。

**错误示例 (Python)：**
```python
# 错误：w 在循环中不断变大，导致后续计算基于错误的数值爆炸式增长
k = 1
while k <= s:
    w = k * w  # 这里的 w 被永久修改了！
    # ...
    k *= 2
```

**纠正方法：**
在 `while` 循环外部声明基准变量（如 `base_w`, `base_v`），循环内部使用 `k * base_w` 进行计算，确保基准值在单种物品的拆分过程中保持不变。

---

## 代码与性能优化策略（Python 特化）

### 1. 流式处理（边拆分边转移）
Python 的列表操作（append, 扩容）虽然方便但也有开销。无需开辟额外的列表来存储拆分后的所有新物品。在计算出一个新包裹的体积和价值后，立即将其代入 0/1 背包的一维状态转移方程中进行处理。

### 2. 消除函数调用开销
Python 的函数调用栈开销相对较大。将状态转移逻辑直接写在拆分的 `while` 循环内部，避免频繁调用独立的 `pack()` 函数。

### 3. 条件判断替代 `max()`
在 Python 中，`max(a, b)` 函数在极高频的循环中（如 DP 最内层）比原生的 `if` 判断要慢。
*   **代码体现**：
    ```python
    # 推荐
    if dp[j - w] + v > dp[j]:
        dp[j] = dp[j - w] + v
    
    # 不推荐 (在紧凑循环中)
    # dp[j] = max(dp[j], dp[j - w] + v)
    ```

### 4. 快速 I/O
对于数据量较大的输入，`input()` 可能会成为瓶颈。建议使用 `sys.stdin.read().split()` 一次性读取所有数据。

---

## 正确答案 (Solution)

```python
import sys

def solve():
    # 使用 iterator 获取数据，极速读取
    data = map(int, sys.stdin.read().split())
    try:
        N = next(data)
        Y = next(data)
    except StopIteration:
        return
        
    dp = [0] * (Y + 1)
    
    for _ in range(N):
        base_w = next(data)
        base_v = next(data)
        s = next(data)
        
        k = 1
        while s >= k:
            w = k * base_w
            v = k * base_v
            # 优化1 & 2：直接展开循环，并用 if 替代 max()
            for j in range(Y, w - 1, -1):
                if dp[j - w] + v > dp[j]:
                    dp[j] = dp[j - w] + v
            s -= k
            k *= 2
            
        if s > 0:
            w = s * base_w
            v = s * base_v
            # 处理余数同样展开
            for j in range(Y, w - 1, -1):
                if dp[j - w] + v > dp[j]:
                    dp[j] = dp[j - w] + v

    print(dp[Y])

if __name__ == '__main__':
    solve()
```
