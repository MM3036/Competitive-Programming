以下是将您的学习笔记整理为 GitHub Markdown 格式的内容，末尾包含了您要求的英文元数据。

***

# 算法学习笔记：动态规划之「不同路径」

## 一、 题目描述（基础版）

### 题目背景与要求
一个机器人位于一个 $m \times n$ 网格的左上角（起始点坐标设为 $(0, 0)$）。
机器人在网格中移动时，受以下规则限制：
1. 每次只能移动一步。
2. 移动方向仅限于 **向下** 或 **向右**。

机器人试图达到网格的右下角（终点坐标为 $(m-1, n-1)$）。
给定网格的行数 $m$ 和列数 $n$，请计算机器人从起始点到达终点，总共有多少条不同的路径。

### 数据范围与约束
- $1 \le m, n \le 100$
- 题目保证最终计算的路径总数在标准整型变量范围内。

### 输入格式
输入一行，包含两个正整数 $m$ 和 $n$，用空格隔开。

### 输出格式
输出一个整数，代表路径总数。

---

## 二、 核心知识点总结

本题是二维动态规划（Dynamic Programming, DP）的经典入门模型，主要包含以下核心考点：

### 1. 二维动态规划基础模型
- **状态定义**：设 $dp[i][j]$ 为到达网格坐标 $(i, j)$ 的总路径数。
- **状态转移方程**：由于机器人只能向右或向下移动，到达 $(i, j)$ 的路径只能从其上方 $(i-1, j)$ 或其左方 $(i, j-1)$ 转移而来。
  $$
  dp[i][j] = dp[i-1][j] + dp[i][j-1]
  $$

### 2. 边界初始化原则
动态规划的递推需要明确的初始状态。
- **第一行**：机器人只能一直向右走才能到达第一行的任何网格，因此到达第一行任意网格的路径数均唯一，即 $dp[0][j] = 1$。
- **第一列**：同理，机器人只能一直向下走才能到达第一列的任何网格，路径数均唯一，即 $dp[i][0] = 1$。

### 3. 空间优化：滚动数组（降维打击）
在状态转移方程中，计算当前行第 $i$ 行的状态时，仅依赖于上一行（第 $i-1$ 行）和当前行左侧（第 $j-1$ 列）的数据。因此，可以将二维数组 $O(m \times n)$ 的空间复杂度优化至一维数组 $O(n)$。

- **一维状态转移方程**：
  $$
  dp[j] = dp[j] + dp[j-1]
  $$

- **原理解析**：
  - 等号右侧的 $dp[j]$ 在被赋值前，存储的是上一行对应位置的数据（等价于 $dp[i-1][j]$）。
  - 等号右侧的 $dp[j-1]$ 则是当前行刚刚计算出的最新数据（等价于 $dp[i][j-1]$）。
  - 利用内层循环从左至右的更新顺序，实现了空间的原地复用。

### 4. 数学解法（组合数学）
该问题可抽象为排列组合问题。
从左上角到右下角，无论路线如何，总共需要移动 $(m-1) + (n-1)$ 步。在这 $m+n-2$ 步中，必须且仅有 $m-1$ 步是向下的。

- **公式计算**：路径总数即为组合数 $C_{m+n-2}^{m-1}$。
- **竞赛注意事项**：标准库（如 Python 的 `math.comb`）可直接调用此公式，但在存在障碍物或网格权重的进阶题目中，数学方法失效，必须依赖动态规划。

---

## 三、 个人失误复盘

### 错误点：边界初始化逻辑混淆

**错误代码表现**：
将第一行和第一列的 $dp$ 值初始化为了坐标索引 $i$。

```python
for i in range(n):
    dp[0][i] = i  # 错误！
```

**错误原因分析**：
混淆了“网格的坐标位置”与“到达该网格的路径总数”这两个概念。$dp$ 数组内存储的物理意义应为 **“方法数/路径数”**，而非坐标值。

**纠正方案**：
明确状态数组的物理含义。第一行和第一列的任何一个格子，从起点出发都只有 1 种走法（即直线走到黑），因此正确的初始化应统一赋值为 **1**。

---

## 四、 正确题解（AC 代码）

```python
m, n = map(int, input().split())

# 只需要一个长度为 n 的一维数组，全部初始化为 1
dp = [1] * n

for i in range(1, m):
    for j in range(1, n):
        # 当前格子 = 上面的值(旧的dp[j]) + 左边的值(新算出的dp[j-1])
        dp[j] += dp[j - 1] 

print(dp[-1]) # 打印最后一个元素
```

