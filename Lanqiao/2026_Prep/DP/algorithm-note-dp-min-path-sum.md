# 算法学习笔记：动态规划之「最小路径和」

## 一、 题目描述（进阶版）

### 题目背景与要求
给定一个包含非负整数的 $m \times n$ 网格 `grid`，请找出一条从左上角（坐标 $(0, 0)$）到右下角（坐标 $(m-1, n-1)$）的路径，使得路径上的数字总和为最小。

### 移动规则
- 机器人每次只能 **向下** 或者 **向右** 移动一步。

### 数据范围与约束
- $1 \le m, n \le 200$
- 网格内的数值均为非负整数（单格数值 $\le 100$）。
- **注意**：题目约束下，单纯的组合数学公式由于网格权重的引入而完全失效，必须使用 **动态规划** 求解最优决策。

### 输入格式
第一行包含两个整数 $m$ 和 $n$，分别表示网格的行数和列数。
接下来的 $m$ 行，每行包含 $n$ 个用空格隔开的非负整数，表示网格上对应位置的数值。

### 输出格式
输出一个整数，表示从左上角到右下角的最小路径和。

---

## 二、 核心知识点总结

本题是二维动态规划中的“带有权重的路径寻优”问题，主要包含以下核心考点及工程实现技巧：

### 1. 状态定义与转移方程
- **状态定义**：设 $dp[i][j]$ 为从起点走到网格坐标 $(i, j)$ 时所累积的 **最小路径和**。
- **状态转移方程**：进入坐标 $(i, j)$ 只有两种可能（从上方或从左方），因此当前格子的最小代价等于当前格子的权重，加上相邻两个前驱状态中的较小值。
  $$
  dp[i][j] = grid[i][j] + \min(dp[i-1][j], dp[i][j-1])
  $$

### 2. 边界初始化的“前缀和”本质
第一行与第一列具有特殊性：
- 对于第一行的网格，由于只能从左侧单向走来，其状态累积过程本质上就是求一维前缀和。
- 第一列同理，只能从上方单向走来。

**初始化公式**：
- **第一行**：$dp[0][j] = dp[0][j] + dp[0][j-1]$
- **第一列**：$dp[i][0] = dp[i][0] + dp[i-1][0]$

### 3. 工程技巧：边界分离与性能优化
- **边界分离原则**：在编写 DP 算法时，应将边界条件的初始化（如第一行、第一列）与主转移逻辑（内部网格）解耦，**切忌**在主循环中使用 `if-else` 进行分类讨论。
- **优势**：
  1. 避免逻辑重叠与多次重复累加的风险。
  2. 极大地减少底层条件分支跳转指令，在算法竞赛（如蓝桥杯）中可显著提升代码运行效率。

### 4. 空间优化：一维滚动数组与流式读取
- **降维原理**：状态转移仅依赖于正上方（旧的 $dp[j]$）与正左方（刚更新的 $dp[j-1]$）的数据。
- **极致优化结合**：配合 Python 的 `sys.stdin.read().split()` 与迭代器 `next()`，可实现流式读取。无需将整个矩阵存入内存，利用单个长度为 $n$ 的一维数组即可完成全局状态推演，将空间复杂度由 $O(m \times n)$ 降至严格的 $O(n)$。

---

## 三、 个人失误复盘

在代码初次实现过程中，出现以下典型错误，需作为后续编码避坑指南：

### 失误点 1：Python 特有的“负索引”陷阱
- **错误表现**：在处理第一行（$i=0$）的越界逻辑时，错误地调用了 `dp[i-1][j]`（即 `dp[-1][j]`）。
- **原因剖析**：在 C++ 等语言中，索引 `-1` 会触发数组越界报错（Index Out of Bounds），能迅速定位问题；但在 Python 中，`dp[-1]` 合法且指向数组的最后一行。这导致第一行的状态错误地融合了最后一行的垃圾数据，引发严重的逻辑污染。
- **规避方案**：严格执行“边界分离”，不让 $i=0$ 或 $j=0$ 的情况进入涉及 $i-1$ 或 $j-1$ 的核心状态转移循环。

### 失误点 2：边界逻辑与主循环高度耦合导致重叠
- **错误表现**：在内层循环中同时使用 `if i < 1:` 和 `if j < 1:` 且未中断当前循环结构。
- **原因剖析**：当处理坐标 $(0, 1)$ 时，程序先命中 `i < 1` 的条件执行了一次累加，随后继续向下执行常规的状态转移方程，导致同一个网格的状态被重复计算、反复累加。
- **规避方案**：第一行单独循环处理，第一列单独循环处理，主网格从 $(1, 1)$ 开始双重循环。

---

## 四、 正确题解（AC 代码）

```python
import sys

data = iter(map(int, sys.stdin.read().split())) # 加上 iter() 更规范稳妥
m = next(data)
n = next(data)

# 初始化第一行并计算前缀和
dp = [next(data) for _ in range(n)]
for j in range(1, n):
    dp[j] += dp[j - 1]

# 遍历剩下的 m-1 行
for i in range(1, m): # i 代表行
    for j in range(n): # j 代表列
        if j == 0:
            # 第一列特殊处理：直接累加当前格子的值（从上面走下来）
            dp[j] += next(data)
        else:
            # 核心转移方程：当前格子值 + min(上方最小代价, 左方最小代价)
            dp[j] = next(data) + min(dp[j], dp[j - 1])

print(dp[-1])
```
